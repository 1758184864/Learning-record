## 什么是若依

> 一个开源的后台管理项目

官网：http://www.ruoyi.vip/

文档：http://doc.ruoyi.vip/

## 配置启动若依

### 后端配置

1. 下载源码
2. 创建数据库，执行sql
3. 设置项目 JDK 为1.8
4. 修改配置文件`application-druid.yml`中的数据库配置
5. 开启本地redis服务，如果是远程的，需要在`application.yml`文件中配置redis的地址

如果遇到启动时提示 JDK 版本低，有不兼容语法，在顶层pom文件中加入如下配置

```xml
 <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>
```

### 前端配置

1. 安装依赖

```bash
npm insttall
```

2. 启动

```bash
npm run dev
```

## 登录

### 生成验证码

#### 流程思路

- 后端生成一个表达式`1+1=?@2 `
- 1+1=? 转成图片，传到前端进行展示
- 2 存入 Reids

#### 获取验证图片

前端请求后端获取图片的接口：http://localhost/dev-api/captchaImage

这里请求后端接口用到了反向代理，解决跨域问题，在vue的配置文件里面可以看到

![反向代理](D:\Study\Learning-record\若依框架\反向代理.png)

```
/dev-api 替换成'' 再映射到后端地址：http://localhost:8080
最后替换之后的请求地址为：http://localhost:8080/captchaImage
```

### 登录流程

#### 前端

登录页面调用登录函数，登录函数进行了封装

![登录函数1](D:\Study\Learning-record\若依框架\登录函数1.png)

![登录函数2](D:\Study\Learning-record\若依框架\登录函数2.png)

登录页的handleLogin函数调用了`user.js`中的Login方法，Login方法调用了`login.js`中的login方法，传入四个参数`username`、`password`、`code`、`uuid`

`uuid`是获取验证码图片时从后端传过来的，保存在表单隐藏域中

在登录成功后，前端保存登录Token

#### 后端

`SysLoginController.java`

```java
@PostMapping("/login")
public AjaxResult login(@RequestBody LoginBody loginBody)
{
    AjaxResult ajax = AjaxResult.success();
    // 生成令牌
    String token = loginService.login(loginBody.getUsername(), loginBody.getPassword(), loginBody.getCode(),
                                      loginBody.getUuid());
    ajax.put(Constants.TOKEN, token);
    return ajax;
}
```

后端接收前端请求，调用`loginService.login`方法进行校验

校验流程：

1. 校验验证码
2. 校验用户名和密码
3. 生成Token

异常代码块中使用异步任务管理器，结合线程池，实现了异步处理操作日志，与业务逻辑进行分离，实现了异步解耦合。

![异步日志记录](D:\Study\Learning-record\若依框架\异步日志记录.png)

### 获取用户权限信息

`getInfo`请求来获取用户权限信息

我们判断`getInfo`和`getRouters`这两个请求是跟随每一次页面跳转的，所以我们去`permission.js`这个文件查看，这个文件管理了全局路由

![全局路由](D:\Study\Learning-record\若依框架\全局路由.png)

前端`GetInfo`方法调用`login.js`中的`getInfo`方法

后端返回查询到的结果，前端使用VueX对用户信息、角色、权限进行存储

![获取用户信息1](D:\Study\Learning-record\若依框架\获取用户信息1.png)

![获取用户信息2](D:\Study\Learning-record\若依框架\获取用户信息2.png)

### 获取导航菜单

`getRouters`请求来获取导航菜单

前端`GenerateRoutes`方法调用`menu.js`中的`getRouters`方法

![获取导航菜单1](D:\Study\Learning-record\若依框架\获取导航菜单1.png)

![获取导航菜单2](D:\Study\Learning-record\若依框架\获取导航菜单2.png)

根据指定父节点id，进行递归查找，最后返回一个菜单集合

```java
/**
 * 根据用户ID查询菜单
 * 
 * @param userId 用户名称
 * @return 菜单列表
 */
@Override
public List<SysMenu> selectMenuTreeByUserId(Long userId)
{
    List<SysMenu> menus = null;
    if (SecurityUtils.isAdmin(userId))
    {
        menus = menuMapper.selectMenuTreeAll();
    }
    else
    {
        menus = menuMapper.selectMenuTreeByUserId(userId);
    }
    return getChildPerms(menus, 0);
}
```

```java
/**
 * 根据父节点的ID获取所有子节点
 * 
 * @param list 分类表
 * @param parentId 传入的父节点ID
 * @return String
 */
public List<SysMenu> getChildPerms(List<SysMenu> list, int parentId)
{
    List<SysMenu> returnList = new ArrayList<SysMenu>();
    for (Iterator<SysMenu> iterator = list.iterator(); iterator.hasNext();)
    {
        SysMenu t = (SysMenu) iterator.next();
        // 一、根据传入的某个父节点ID,遍历该父节点的所有子节点
        if (t.getParentId() == parentId)
        {
            recursionFn(list, t);
            returnList.add(t);
        }
    }
    return returnList;
}
```

### 首页数据加载

通过分析，发现登录成功后，调用根路由，根路由跳转到`layout`文件夹，由此判断`layout/index.vue`就是我们的主页面，`layout/components/Sider/index.vue`是侧边菜单栏，可以看见遍历生成代码

```html
<sidebar-item
    v-for="(route, index) in sidebarRouters"
    :key="route.path  + index"
    :item="route"
    :base-path="route.path"
/>
```

每一个菜单项所绑定的页面路径，是在数据库`sys_menu`表中通过`component`字段进行指定的

## 用户管理

用户管理界面在加载时，调用了两个重要函数`getList()`和`getDeptTree()`，用于获取右侧表格数据以及左侧树状结构

![用户管理构建函数](D:\Study\Learning-record\若依框架\用户管理构建函数.png)

### getList()

#### 分页

前端携带两个参数：查询数据、查询日期范围来请求后端接口

后端使用PageHelper对查询到的数据列表进行了分页、封装的操作

PageHelper中的reasonable对参数进行逻辑处理，保证参数的正确性，

比如传入不合理的页码字符，就会自动处理为1

#### 权限

在后端接口上有一个自定义注解`@PreAuthorize("@ss.hasPermi('system:user:list')")`，用于验证当前用户是否有调用此接口的权限，权限信息保存在redis当中，可以直接获取

#### 表别名

在数据查询接口上我们看到一个自定义注解

`@DataScope(deptAlias = "d", userAlias = "u")`，此注解是在查询时给数据库表添加别名的，缩减查询语句

### getDeptTree()

前端单纯调用了一个get请求来向后端请求数据

#### 构建树状结构

后端查询部门数据集合，再处理此集合，构造出树状结构，构建逻辑和动态路由思路一致，递归构建

```java
/**
 * 构建前端所需要树结构
 * 
 * @param depts 部门列表
 * @return 树结构列表
 */
@Override
public List<SysDept> buildDeptTree(List<SysDept> depts)
{
    List<SysDept> returnList = new ArrayList<SysDept>();
    List<Long> tempList = depts.stream().map(SysDept::getDeptId).collect(Collectors.toList());
    for (SysDept dept : depts)
    {
        // 如果是顶级节点, 遍历该父节点的所有子节点
        if (!tempList.contains(dept.getParentId()))
        {
            recursionFn(depts, dept);
            returnList.add(dept);
        }
    }
    if (returnList.isEmpty())
    {
        returnList = depts;
    }
    return returnList;
}
```

#### 前端映射

对于构建好的树状结构，使用`stream()`进行处理，与前端字段进行了映射，相当于copy，然后对不必要的字段进行了删减

```java
/**
 * 构建前端所需要下拉树结构
 * 
 * @param depts 部门列表
 * @return 下拉树结构列表
 */
@Override
public List<TreeSelect> buildDeptTreeSelect(List<SysDept> depts)
{
    List<SysDept> deptTrees = buildDeptTree(depts);
    return deptTrees.stream().map(TreeSelect::new).collect(Collectors.toList());
}
```

### 前端数据渲染

前端使用el-tree渲染出树状结构

```html
<el-tree
  :data="deptOptions"
  :props="defaultProps"
  :expand-on-click-node="false"
  :filter-node-method="filterNode"
  ref="tree"
  node-key="id"
  default-expand-all
  highlight-current
  @node-click="handleNodeClick"
/>
```

### 条件查询

对于树状结构的每一项，点击时，都相当于进行了条件查询，条件为部门ID

`http://localhost/dev-api/system/user/list?pageNum=1&pageSize=10&deptId=103`

```javascript
// 节点单击事件
handleNodeClick(data) {
    this.queryParams.deptId = data.id;
    this.handleQuery();
},
```

### 添加数据

点击新增按钮，调用`handleAdd`函数，此函数首先对表单进行重置操作，然后请求了角色集和岗位集，用于填充表单下拉框。归属部门下拉框直接使用进入页面时查询的树状图来进行填充

![新增按钮函数1](D:\Study\Learning-record\若依框架\新增按钮函数1.png)

跟进`getUser()`，此请求分为携带userId和不携带参数，两种

![新增按钮函数2](D:\Study\Learning-record\若依框架\新增按钮函数2.png)

查看后端接口，后端使用一个函数，对于新增和修改两种情况进行了处理，携带用户id的视为修改，不携带则为新增分别返回不同的用户参数到前端，在返回之前，使用`stream()`对角色集进行了过滤，规定当前用户能新增的角色类型不能为超级管理员

```java
/**
 * 根据用户编号获取详细信息
 */
@PreAuthorize("@ss.hasPermi('system:user:query')")
@GetMapping(value = { "/", "/{userId}" })
public AjaxResult getInfo(@PathVariable(value = "userId", required = false) Long userId)
{
    userService.checkUserDataScope(userId);
    AjaxResult ajax = AjaxResult.success();
    List<SysRole> roles = roleService.selectRoleAll();
    ajax.put("roles", SysUser.isAdmin(userId) ? roles : roles.stream().filter(r -> !r.isAdmin()).collect(Collectors.toList()));
    ajax.put("posts", postService.selectPostAll());
    if (StringUtils.isNotNull(userId))
    {
        SysUser sysUser = userService.selectUserById(userId);
        ajax.put(AjaxResult.DATA_TAG, sysUser);
        ajax.put("postIds", postService.selectPostListByUserId(userId));
        ajax.put("roleIds", sysUser.getRoles().stream().map(SysRole::getRoleId).collect(Collectors.toList()));
    }
    return ajax;
}
```

点击确认按钮，调用提交函数，发起提交

![新增表单提交](D:\Study\Learning-record\若依框架\新增表单提交.png)

查看后端接口函数，对于新增用户，首先进行了唯一性验证，然后密码进行了md5加密，完成新增

![新增用户](D:\Study\Learning-record\若依框架\新增用户.png)

### 修改用户

前端点击修改按钮，弹出修改框，修改需要修改的用户ID，查询出数据放回并渲染修改弹窗，同时也请求了角色集、岗位集，与新增函数基本类似，唯一不同的就是，后端多返回了一个data数据，里面封装了当前修改用户的基本信息。

```java
/** 数据对象 */
public static final String DATA_TAG = "data";
```

```java
SysUser sysUser = userService.selectUserById(userId);
ajax.put(AjaxResult.DATA_TAG, sysUser);
```

数据库层操作，这里对于两张逻辑表的操作是，先删除当前用户已有关系，再建立新的关系

![修改用户](D:\Study\Learning-record\若依框架\修改用户.png)

### 删除用户

删除用户，前端将用户ID传入后端进行处理，后端拿到id，首先进行验证，此用户能否删除，比如当前登录用户和超级管理员就无法删除

验证通过进行删除操作，首先删除逻辑表中的数据，然后对用户进行逻辑删除

![删除用户](D:\Study\Learning-record\若依框架\删除用户.png)

## 异步任务管理器

AsyncManager.me().execute(AsyncFactory.recordLog ininfor(username, Constants.LOGIN_FAIL, MessageUtils.message("user.password.not.match"))); 通过异步任务管理器记录登录日志 1、AsyncManager.me() 获取一个 AsycnManager 对象 2、执行 execute 方法，执行任务，传入的是一个 Task 对象，实现了 Runnable 接口，是一个任务，由线程 Thread 去执行

```java
public static TimerTask recordLogininfor(final String username, final String status, final String message,
        final Object... args)
{
    final UserAgent userAgent = UserAgent.parseUserAgentString(ServletUtils.getRequest().getHeader("User-Agent"));
    final String ip = IpUtils.getIpAddr(ServletUtils.getRequest());
    return new TimerTask()
    {
        @Override
        public void run()
        {
            String address = AddressUtils.getRealAddressByIP(ip);
            StringBuilder s = new StringBuilder();
            s.append(LogUtils.getBlock(ip));
            s.append(address);
            s.append(LogUtils.getBlock(username));
            s.append(LogUtils.getBlock(status));
            s.append(LogUtils.getBlock(message));
            // 打印信息到日志
            sys_user_logger.info(s.toString(), args);
            // 获取客户端操作系统
            String os = userAgent.getOperatingSystem().getName();
            // 获取客户端浏览器
            String browser = userAgent.getBrowser().getName();
            // 封装对象
            SysLogininfor logininfor = new SysLogininfor();
            logininfor.setUserName(username);
            logininfor.setIpaddr(ip);
            logininfor.setLoginLocation(address);
            logininfor.setBrowser(browser);
            logininfor.setOs(os);
            logininfor.setMsg(message);
            // 日志状态
            if (StringUtils.equalsAny(status, Constants.LOGIN_SUCCESS, Constants.LOGOUT, Constants.REGISTER))
            {
                logininfor.setStatus(Constants.SUCCESS);
            }
            else if (Constants.LOGIN_FAIL.equals(status))
            {
                logininfor.setStatus(Constants.FAIL);
            }
            // 插入数据
            SpringUtils.getBean(ISysLogininforService.class).insertLogininfor(logininfor);
        }
    };
}
```

封装了登录用户的信息，执行添加操作，这里不会执 行，而是将任务交给线程对象来执行。 异步任务管理器，内部定义了一个线程池，然后根据业 务创建添加日志的任务，交给线程池来处理，这样做到 日志和业务的抽象，解耦合，日志全部统一处理。
