## JVM是什么

> JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。

Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。

## Java的跨平台实现

Java语言的跨平台特性就是依靠JVM来实现的。就像我们所使用的一些应用软件一样，针对不同的操作系统，有不同的JVM，我们只需要进行相应的安装配置即可

Java源代码文件通过编译之后，产生的以`.class`结尾的字节码文件可以直接运行在JVM上面，从而实现跨平台，同一份字节码文件通过JVM，可以不加修改就运行在不同操作系统上，也就是所说的`一次编译，处处运行`。

![Java运行流程](D:\Study\Learning-record\JVM\Java运行流程.png)

## JVM内存结构

![JVM内存结构](D:\Study\Learning-record\JVM\JVM内存结构.jpg)

​	JVM的运行时数据区分为：方法区、堆、栈、本地方法栈、程序计数器

### 方法区

方法区只是一个逻辑上的概念

随着JDK的更新，具体实现如下，参考：[方法区、永久代、元空间的区别](https://blog.csdn.net/qq_38262266/article/details/107208357)

| JDK版本 | 方法区的实现 | 运行时常量池的位置 |
| :-----: | :----------: | :----------------: |
| JDK1.6  |    永久代    |       永久代       |
| JDK1.7  |    永久代    |         堆         |
| JDK1.8+ |    元空间    |         堆         |

方法区用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，常量池，编译后代码···等，类加载器将`.class`文件搬过来就是先丢到这一块上

==元空间使用的是本地内存，它不存在于JVM当中==

### 堆

主要存放一些数据，例如：对象实例、数组...

堆被划分为了新生代和老年代两块区域，内存占比`2:1`

新生代又被划分为了Eden、From Survivor、To Survivor这三块区域，内存占比`8:1:1`

新创建的对象一般都存在于新生代当中，如果对象在经历了15次垃圾回收之后还处于存活状态，则会转移到老年代当中，或者是创建的较大对象，由于比较占用内存，就会直接放入老年代当中，使用`-XX:PretenureSizeThreshold`可以手动设置大对象大小限制

![堆内存空间](D:\Study\Learning-record\JVM\堆内存空间.jpg)

### 栈

用来执行方法的，每一个被调用的方法都是一个栈帧，栈帧包含方法的基本信息，栈顶永远是当前线程正在执行的方法，方法执行完毕后，就会被弹出栈空间。

![栈内存空间](D:\Study\Learning-record\JVM\栈内存空间.jpg)

### 本地方法栈

本地方法栈用于执行一些非java语言编写的方法，这些方法都用`native`关键字进行修饰

### 程序计数器

占用极小内存，用于记录当前线程所要执行的下一条指令的地址

是唯一一个在JVM规范中没有规定任何内存溢出问题的区域。

## 内存溢出与栈溢出

栈溢出问题(StackOverflowError)：由于当前栈空间不够用，只压栈不出栈而导致，一般是由递归或是两个方法相互调用所引起

内存溢出问题(OutOfMemoryError)：由于线程太多，占用过多内存，无法创建新的线程所导致

## 类加载

### 类的生命周期

从类被加载到虚拟机内存中开始，到释放内存总共有 7 个阶段：加载，验证，准备，解析，初始化，使用，卸载。其中，验证，准备，解析三个部分统称为**连接**

#### 加载

1. 将 `.class`文件加载到内存
2. 将静态数据结构转化成方法区中运行时的数据结构
3. 在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口

#### 连接

1. 验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查
2. 准备：为 static 变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）
3. 解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在 import java.util.ArrayList 这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）

#### 初始化

初始化其实就是执行类构造器方法的`<clinit>()`的过程，而且要保证执行前父类的`<clinit>()`方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static 修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 `static int a` 由默认初始化的 0 变成了显式初始化的 3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。

> 注意：字节码文件中初始化方法有两种，非静态资源初始化的`<init>`和静态资源初始化的`<clinit>`，类构造器方法`<clinit>()`不同于类的构造器，这些方法都是字节码文件中只能给 JVM 识别的特殊方法。

#### 卸载

通过GC进行垃圾回收，方法区中的类信息也会被一同删除，然后释放内存

### 类加载器

根加载器(BootStrap ClassLoader)：加载`jre\lib\rt.jar`中存放的Java核心类

扩展加载器(Extension ClassLoader)：加载`jre\lib\ext`中的扩展jar包

应用加载器(App ClassLoader)：加载`classpath`下的jar包

Custom ClassLoader：自定义的类加载器

### 双亲委派机制

![双亲委派机制](D:\Study\Learning-record\JVM\双亲委派机制.jpg)

流程：当一个类加载器收到加载请求时，会向上委托父加载器来完成，每一层加载器都会在缓存中查询当前请求的类是否已经加载过，如果有就不用再重新加载了，如果没有，则继续将加载请求向上传递。当请求到达根加载器时，开始进行加载，如果无法加载就将请求向下传递，由子加载器来进行加载，层层向下，最终完成类的加载，如果都无法加载，会抛出`ClassNotFoundException`。

好处：避免重复加载；防止核心类被覆盖，保证安全性

## 垃圾回收（Garbage Collection）机制

### 垃圾标记

要进行垃圾回收，第一步是要找到垃圾，这里就有两个算法引用计数法和可达分析法

#### 引用计数法（几乎不使用）

为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。

缺点：

- 需要额外的空间来存储引用计数
- 需要额外的时间来维护引用计数
- 无法处理循环引用问题

#### 可达分析法

从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。

### STW（Stop The World）

Stop一the一World，简称STW，指的是Gc事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW

### 垃圾回收算法

#### 标记-清除算法

先遍历堆内存空间标记垃圾，标记完成后，再次遍历堆内存空间，对标记了的对象进行回收

缺点：

1. 效率不高：因为在标记的时候要遍历一次，清除的时候还要遍历一次
2. 产生内存碎片：回收后，产生不连续的内存，一些对象稍微大一点就无法存入

![标记-清除算法](D:\Study\Learning-record\JVM\标记-清除算法.jpg)

#### 复制算法

将当前内存块的可达对象复制到另一个空内存块中，然后就认为当前内存块为空，下一次直接覆盖使用即可，不用再单独清理。每一次垃圾清理都将这两块内存轮流复制，实际上就是新生代的From Survivor、To Survivor这两块区域。

优点：

1. 效率高：直接复制，没有标记过程，而且只遍历一次
2. 不会出现内存碎片

缺点：

1. 需要更多的内存：始终有一半的闲置内存来用于垃圾回收
2. 对象复制后，内存地址发生变化，需要额外时间来修改栈帧中的引用地址
3. 如果可达对象比较多，那么它们都需要复制，效率就会低下

![复制算法](D:\Study\Learning-record\JVM\复制算法.jpg)

#### 标记-整理算法

先遍历堆内存空间标记垃圾，标记完成后，再次遍历堆内存空间，对标记了的对象进行移动整理，最后对垃圾对象进行回收

优点：

1. 不会出现内存碎片
2. 不需要利用额外的内存空间

缺点：

1. 效率比前面两个算法都低一些，因为它相当于是两者的结合
2. 同样也需要修改栈帧中的引用地址

![标记-整理算法](D:\Study\Learning-record\JVM\标记-整理算法.jpg)

### 分代收集理论

不同的对象的存活时间不一样，所以针对不同的对象采用不同的垃圾回收算法

新生代中的对象存活时间较短，所以使用`复制算法`

老年代中的对象存活时间较长，所以使用`标记-清除算法`或`标记-整理算法`

### 七大垃圾回收器

参考：[如何掌握Java JVM垃圾回收器，有哪些基础知识](www.qycn.com/xzx/article/15462.html)

|    垃圾回收器     | 分类 |    作用位置    |        算法         | 特点         | 使用场景                                  |
| :---------------: | :--: | :------------: | :-----------------: | :----------- | :---------------------------------------- |
|      Serial       | 串行 |     新生代     |      复制算法       | 响应速度优先 | 单CPU环境下的Client模式                   |
|    Serial Old     | 串行 |     老年代     |      标记-整理      | 响应速度优先 | 单CPU环境下的Client模式、CMS的备选方案    |
|      ParNew       | 并行 |     新生代     |      复制算法       | 响应速度优先 | 多CPU环境时在Server模式下与CMS配合        |
| Parallel Scavenge | 并行 |     新生代     |      复制算法       | 吞吐量优先   | 在后台运算而不需要太多交互的任务          |
|   Parallel Old    | 并行 |     老年代     |      标记-整理      | 吞吐量优先   | 在后台运算而不需要太多交互的任务          |
|        CMS        | 并发 |     老年代     |      标记-清除      | 响应速度优先 | 集中在互联网站或B/S系统服务端上的Java应用 |
|        G1         | 并发 | 新生代和老年代 | 标记-整理和复制算法 | 响应速度优先 | 面对服务端应用，将来替换CMS               |

到 jdk8 为止，默认的垃圾收集器是 Parallel Scavenge 和 Parallel Old，从 jdk9 开始，G1 收集器成为默认的垃圾收集器。
