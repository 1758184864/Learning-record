## JVM是什么

> JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。

Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。

## Java的跨平台实现

Java语言的跨平台特性就是依靠JVM来实现的。就像我们所使用的一些应用软件一样，针对不同的操作系统，有不同的JVM，我们只需要进行相应的安装配置即可

Java源代码文件通过编译之后，产生的以`.class`结尾的字节码文件可以直接运行在JVM上面，从而实现跨平台，同一份字节码文件通过JVM，可以不加修改就运行在不同操作系统上，也就是所说的`一次编译，处处运行`。

![Java运行流程](D:\Study\Learning-record\JVM\Java运行流程.png)

## JVM内存结构

![JVM内存结构](D:\Study\Learning-record\JVM\JVM内存结构.jpg)

​	JVM的运行时数据区分为：方法区、堆、栈、本地方法栈、程序计数器

### 方法区

方法区只是一个逻辑上的概念

随着JDK的更新，具体实现如下，参考：[方法区、永久代、元空间的区别](https://blog.csdn.net/qq_38262266/article/details/107208357)

| JDK版本 | 方法区的实现 | 运行时常量池的位置 |
| :-----: | :----------: | :----------------: |
| JDK1.6  |    永久代    |       永久代       |
| JDK1.7  |    永久代    |         堆         |
| JDK1.8+ |    元空间    |         堆         |

方法区用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，常量池，编译后代码···等，类加载器将`.class`文件搬过来就是先丢到这一块上

==元空间使用的是本地内存，它不存在于JVM当中==

### 堆

主要存放一些数据，例如：对象实例、数组...

堆被划分为了新生代和老年代两块区域，内存占比`2:1`

新生代又被划分为了Eden、From Survivor、To Survivor这三块区域，内存占比`8:1:1`

新创建的对象一般都存在于新生代当中，如果对象在经历了15次垃圾回收之后还处于存活状态，则会转移到老年代当中，或者是创建的较大对象，由于比较占用内存，就会直接放入老年代当中，使用`-XX:PretenureSizeThreshold`可以手动设置大对象大小限制

![堆内存空间](D:\Study\Learning-record\JVM\堆内存空间.jpg)

### 栈

用来执行方法的，每一个被调用的方法都是一个栈帧，栈帧包含方法的基本信息，栈顶永远是当前线程正在执行的方法，方法执行完毕后，就会被弹出栈空间。

![栈内存空间](D:\Study\Learning-record\JVM\栈内存空间.jpg)

### 本地方法栈

本地方法栈用于执行一些非java语言编写的方法，这些方法都用`native`关键字进行修饰

### 程序计数器

占用极小内存，用于记录当前线程所要执行的下一条指令的地址

是唯一一个在JVM规范中没有规定任何内存溢出问题的区域。

## 内存溢出与栈溢出

栈溢出问题(StackOverflowError)：由于当前栈空间不够用，只压栈不出栈而导致，一般是由递归或是两个方法相互调用所引起

内存溢出问题(OutOfMemoryError)：由于线程太多，占用过多内存，无法创建新的线程所导致

## 类加载

### 类的生命周期

从类被加载到虚拟机内存中开始，到释放内存总共有 7 个阶段：加载，验证，准备，解析，初始化，使用，卸载。其中，验证，准备，解析三个部分统称为**连接**

#### 加载

1. 将 `.class`文件加载到内存
2. 将静态数据结构转化成方法区中运行时的数据结构
3. 在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口

#### 连接

1. 验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查
2. 准备：为 static 变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）
3. 解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在 import java.util.ArrayList 这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）

#### 初始化

初始化其实就是执行类构造器方法的`<clinit>()`的过程，而且要保证执行前父类的`<clinit>()`方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static 修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 `static int a` 由默认初始化的 0 变成了显式初始化的 3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。

> 注意：字节码文件中初始化方法有两种，非静态资源初始化的`<init>`和静态资源初始化的`<clinit>`，类构造器方法`<clinit>()`不同于类的构造器，这些方法都是字节码文件中只能给 JVM 识别的特殊方法。

#### 卸载

通过GC进行垃圾回收，方法区中的类信息也会被一同删除，然后释放内存

### 类加载器

根加载器(BootStrap ClassLoader)：加载`jre\lib\rt.jar`中存放的Java核心类

扩展加载器(Extension ClassLoader)：加载`jre\lib\ext`中的扩展jar包

应用加载器(App ClassLoader)：加载`classpath`下的jar包

Custom ClassLoader：自定义的类加载器

### 双亲委派机制

![双亲委派机制](D:\Study\Learning-record\JVM\双亲委派机制.jpg)

流程：当一个类加载器收到加载请求时，会向上委托父加载器来完成，每一层加载器都会在缓存中查询当前请求的类是否已经加载过，如果有就不用再重新加载了，如果没有，则继续将加载请求向上传递。当请求到达根加载器时，开始进行加载，如果无法加载就将请求向下传递，由子加载器来进行加载，层层向下，最终完成类的加载，如果都无法加载，会抛出`ClassNotFoundException`。

好处：避免重复加载；防止核心类被覆盖，保证安全性

## 垃圾回收（Garbage Collection）机制

### 垃圾标记

要进行垃圾回收，第一步是要找到垃圾，这里就有两个算法引用计数法和可达分析法

#### 引用计数法

为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。

缺点：

- 需要额外的空间来存储引用计数
- 需要额外的时间来维护引用计数
- 无法处理循环引用问题

#### 可达分析法

从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。

### 垃圾清除算法

#### 复制算法

#### 标记-清理算法

#### 标记-整理算法

#### 分代整理算法