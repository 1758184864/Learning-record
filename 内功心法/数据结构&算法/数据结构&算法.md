## 算法定义

- 一个有限指令集
- 接受一些输入（有些情况下不需要输入）
- 产生输出
- 一定在有限步骤之后终止
- 每一条指令必须
  - 有充分明确的目标
  - 不可以有歧义
  - 计算机能处理的范围之内
  - 描述应不依赖于任何一种计算机语言以及具体的实现手段

## 算法的复杂度

### 空间复杂度S(n)

根据算法写成的程序在执行时**占用存储单元的长度**。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断

### 时间复杂度T(n)

根据算法写成的程序在执行时**耗费时间的长度**。这个长度往往也与输入数据的规模相关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果。

### 复杂度的渐进表示法

上界：T(n) = O(f(n)) 表示存在常数C>0,n0>0，使得当n >= n0时，有T(n) <= C·f(n)

下界：T(n) = Ω(g(n)) 表示存在常数C>0,n0>0，使得当n >= n0时，有T(n) >= C·g(n)

T(n) = Θ(h(n)) 表示同时有T(n) = O(h(n))和T(n) = Ω(h(n))

==在分析算法效率时，我们一般找最小上界以及最大下界来进行分析==

### 复杂度分析

- for循环的时间复杂度：等于循环次数乘以循环体代码的复杂度

- if-else结构的复杂度：总体复杂度取三者中最大

平均复杂度Tavg(n) >= 最坏情况复杂度Tworst(n)，==我们一般分析最坏情况复杂度==

## 分治算法基本思想

字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……

详解：https://www.iteye.com/blog/javablogs-2070840

## 在线处理基本思想

`在线`的意思是指每一输入一个数据就进行及时处理，在任何一个地方终止输入，算法都能正确给出当前的解

## 最大子列和问题(分治法、在线处理)

详解：https://blog.csdn.net/wanglinyp/article/details/113851002
