## 什么是若依

> 一个开源的后台管理项目

官网：http://www.ruoyi.vip/

文档：http://doc.ruoyi.vip/

## 配置启动若依

### 后端配置

1. 下载源码
2. 创建数据库，执行sql
3. 设置项目 JDK 为1.8
4. 修改配置文件`application-druid.yml`中的数据库配置
5. 开启本地redis服务，如果是远程的，需要在`application.yml`文件中配置redis的地址

如果遇到启动时提示 JDK 版本低，有不兼容语法，在顶层pom文件中加入如下配置

```xml
 <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>
```

### 前端配置

1. 安装依赖

```bash
npm insttall
```

2. 启动

```bash
npm run dev
```

## 登录

### 生成验证码

#### 流程思路

- 后端生成一个表达式`1+1=?@2 `
- 1+1=? 转成图片，传到前端进行展示
- 2 存入 Reids

#### 获取验证图片

前端请求后端获取图片的接口：http://localhost/dev-api/captchaImage

这里请求后端接口用到了反向代理，解决跨域问题，在vue的配置文件里面可以看到

![反向代理](D:\Study\Learning-record\项目\若依框架\反向代理.png)

```
/dev-api 替换成'' 再映射到后端地址：http://localhost:8080
最后替换之后的请求地址为：http://localhost:8080/captchaImage
```

### 登录流程

#### 前端

登录页面调用登录函数，登录函数进行了封装

![登录函数1](D:\Study\Learning-record\项目\若依框架\登录函数1.png)

![image-20230111115704715](C:\Users\爽\AppData\Roaming\Typora\typora-user-images\image-20230111115704715.png)

![登录函数2](D:\Study\Learning-record\项目\若依框架\登录函数2.png)

登录页的handleLogin函数调用了`user.js`中的Login方法，Login方法调用了`login.js`中的login方法，传入四个参数`username`、`password`、`code`、`uuid`

`uuid`是获取验证码图片时从后端传过来的，保存在表单隐藏域中

在登录成功后，前端保存登录Token

#### 后端

`SysLoginController.java`

```java
@PostMapping("/login")
public AjaxResult login(@RequestBody LoginBody loginBody)
{
    AjaxResult ajax = AjaxResult.success();
    // 生成令牌
    String token = loginService.login(loginBody.getUsername(), loginBody.getPassword(), loginBody.getCode(),
                                      loginBody.getUuid());
    ajax.put(Constants.TOKEN, token);
    return ajax;
}
```

后端接收前端请求，调用`loginService.login`方法进行校验

校验流程：

1. 校验验证码
2. 校验用户名和密码
2. 生成Token

异常代码块中使用异步任务管理器，结合线程池，实现了异步处理操作日志，与业务逻辑进行分离，实现了异步解耦合。

![异步日志记录](D:\Study\Learning-record\项目\若依框架\异步日志记录.png)

### 获取用户权限信息

`getInfo`请求来获取用户权限信息

我们判断`getInfo`和`getRouters`这两个请求是跟随每一次页面跳转的，所以我们去`permission.js`这个文件查看，这个文件管理了全局路由

![全局路由](D:\Study\Learning-record\项目\若依框架\全局路由.png)

前端`GetInfo`方法调用`login.js`中的`getInfo`方法

后端返回查询到的结果，前端使用VueX对用户信息、角色、权限进行存储

![获取用户信息1](D:\Study\Learning-record\项目\若依框架\获取用户信息1.png)

![获取用户信息2](D:\Study\Learning-record\项目\若依框架\获取用户信息2.png)

### 获取导航菜单

`getRouters`请求来获取导航菜单

前端`GenerateRoutes`方法调用`menu.js`中的`getRouters`方法

![获取导航菜单1](D:\Study\Learning-record\项目\若依框架\获取导航菜单1.png)

![获取导航菜单2](D:\Study\Learning-record\项目\若依框架\获取导航菜单2.png)

根据指定父节点id，进行递归查找，最后返回一个菜单集合

```java
/**
 * 根据用户ID查询菜单
 * 
 * @param userId 用户名称
 * @return 菜单列表
 */
@Override
public List<SysMenu> selectMenuTreeByUserId(Long userId)
{
    List<SysMenu> menus = null;
    if (SecurityUtils.isAdmin(userId))
    {
        menus = menuMapper.selectMenuTreeAll();
    }
    else
    {
        menus = menuMapper.selectMenuTreeByUserId(userId);
    }
    return getChildPerms(menus, 0);
}
```

```java
/**
 * 根据父节点的ID获取所有子节点
 * 
 * @param list 分类表
 * @param parentId 传入的父节点ID
 * @return String
 */
public List<SysMenu> getChildPerms(List<SysMenu> list, int parentId)
{
    List<SysMenu> returnList = new ArrayList<SysMenu>();
    for (Iterator<SysMenu> iterator = list.iterator(); iterator.hasNext();)
    {
        SysMenu t = (SysMenu) iterator.next();
        // 一、根据传入的某个父节点ID,遍历该父节点的所有子节点
        if (t.getParentId() == parentId)
        {
            recursionFn(list, t);
            returnList.add(t);
        }
    }
    return returnList;
}
```

### 首页数据加载

通过分析，发现登录成功后，调用根路由，根路由跳转到`layout`文件夹，由此判断`layout/index.vue`就是我们的主页面，`layout/components/Sider/index.vue`是侧边菜单栏，可以看见遍历生成代码

```html
<sidebar-item
    v-for="(route, index) in sidebarRouters"
    :key="route.path  + index"
    :item="route"
    :base-path="route.path"
/>
```

每一个菜单项所绑定的页面路径，是在数据库`sys_menu`表中通过`component`字段进行指定的

## 用户管理

用户管理界面在加载时，调用了两个重要函数`getList()`和`getDeptTree()`，用于获取右侧表格数据以及左侧树状结构

![用户管理构建函数](D:\Study\Learning-record\项目\若依框架\用户管理构建函数.png)

### getList()

#### 分页

前端携带两个参数：查询数据、查询日期范围来请求后端接口

后端使用PageHelper对查询到的数据列表进行了分页、封装的操作

PageHelper中的reasonable对参数进行逻辑处理，保证参数的正确性，

比如传入不合理的页码字符，就会自动处理为1

#### 权限

在后端接口上有一个自定义注解`@PreAuthorize("@ss.hasPermi('system:user:list')")`，用于验证当前用户是否有调用此接口的权限，权限信息保存在redis当中，可以直接获取

#### 表别名

在数据查询接口上我们看到一个自定义注解

`@DataScope(deptAlias = "d", userAlias = "u")`，此注解是在查询时给数据库表添加别名的，缩减查询语句

### getDeptTree()

前端单纯调用了一个get请求来向后端请求数据

#### 构建树状结构

后端查询部门数据集合，再处理此集合，构造出树状结构，构建逻辑和动态路由思路一致，递归构建

```java
/**
 * 构建前端所需要树结构
 * 
 * @param depts 部门列表
 * @return 树结构列表
 */
@Override
public List<SysDept> buildDeptTree(List<SysDept> depts)
{
    List<SysDept> returnList = new ArrayList<SysDept>();
    List<Long> tempList = depts.stream().map(SysDept::getDeptId).collect(Collectors.toList());
    for (SysDept dept : depts)
    {
        // 如果是顶级节点, 遍历该父节点的所有子节点
        if (!tempList.contains(dept.getParentId()))
        {
            recursionFn(depts, dept);
            returnList.add(dept);
        }
    }
    if (returnList.isEmpty())
    {
        returnList = depts;
    }
    return returnList;
}
```

#### 前端映射

对于构建好的树状结构，使用`stream()`进行处理，与前端字段进行了映射，相当于copy，然后对不必要的字段进行了删减

```java
/**
 * 构建前端所需要下拉树结构
 * 
 * @param depts 部门列表
 * @return 下拉树结构列表
 */
@Override
public List<TreeSelect> buildDeptTreeSelect(List<SysDept> depts)
{
    List<SysDept> deptTrees = buildDeptTree(depts);
    return deptTrees.stream().map(TreeSelect::new).collect(Collectors.toList());
}
```

### 前端数据渲染

前端使用el-tree渲染出树状结构

```html
<el-tree
  :data="deptOptions"
  :props="defaultProps"
  :expand-on-click-node="false"
  :filter-node-method="filterNode"
  ref="tree"
  node-key="id"
  default-expand-all
  highlight-current
  @node-click="handleNodeClick"
/>
```

### 条件查询

对于树状结构的每一项，点击时，都相当于进行了条件查询，条件为部门ID

`http://localhost/dev-api/system/user/list?pageNum=1&pageSize=10&deptId=103`

```javascript
// 节点单击事件
handleNodeClick(data) {
    this.queryParams.deptId = data.id;
    this.handleQuery();
},
```

