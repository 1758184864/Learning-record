- 

  



# @responseBody注解的使用

1、

　　@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据，需要注意的呢，在使用此注解之后不会再走试图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。

2、　　

　　@RequestMapping("/login")
	　　@ResponseBody
	　　public User login(User user){
		　　　　return user;
	　　}
	　　User字段：userName pwd
	　　那么在前台接收到的数据为：'{"userName":"xxx","pwd":"xxx"}'
	

	　　效果等同于如下代码：
		　　@RequestMapping("/login")
		　　public void login(User user, HttpServletResponse response){
			　　　　response.getWriter.write(JSONObject.fromObject(user).toString());
		　　}

### 1、概念

​    注解 @ResponseBody，使用在控制层（controller）的方法上。

### 2、作用

​    作用：将方法的返回值，以特定的格式写入到response的body区域，进而将数据返回给客户端。

​    当方法上面没有写ResponseBody,底层会将方法的返回值封装为ModelAndView对象。

​    如果返回值是字符串，那么直接将字符串写到客户端；如果是一个对象，会将对象转化为json串，然后写到客户端。

### 3、注意编码

​     如果返回对象,按utf-8编码。如果返回String，默认按iso8859-1编码，页面可能出现乱码。因此在注解中我们可以手动修改编码格式，例如@RequestMapping(value="/cat/query",produces="text/html;charset=utf-8")，前面是请求的路径，后面是编码格式。

### 4、原理

​     控制层方法的返回值是如何转化为json格式的字符串的？其实是通过HttpMessageConverter中的方法实现的，它本是一个接口，在其实现类完成转换。如果是bean对象，会调用对象的getXXX（）方法获取属性值并且以键值对的形式进行封装，进而转化为json串。如果是map集合，采用get(key)方式获取value值，然后进行封装。



## @RestController

@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。





# Arrays.asList()

　首先，该方法是将数组转化为list。

​	有以下几点需要注意：

　　（1）该方法不适用于基本数据类型（byte,short,int,long,float,double,boolean）

　　（2）该方法将数组与列表链接起来，当更新其中之一时，另一个自动更新

　　（3）不支持add和remove方法

​	代码：

```java
import java.util.Arrays;
import java.util.List;

abstract public class AsllistTest {

    public static void main(String[] args) {
        String[] s = {"aa","bb","cc"};
        List<String> strlist = Arrays.asList(s);
        for(String str:strlist){
            System.out.println(str);
        }
        System.out.println("------------------------");
        //基本数据类型结果打印为一个元素
        int[] i ={11,22,33}; 
        List intlist = Arrays.asList(i);
        for(Object o:intlist){
            System.out.println(o.toString());
        }
        System.out.println("------------------------");
        Integer[] ob = {11,22,33};
        List<Integer> oblist = Arrays.asList(ob);
        for(int a:oblist){
            System.out.println(a);
        }
        System.out.println("------------------------");
    }
}
```

```jieguo
aa
bb
cc
------------------------
[I@77459877
------------------------
11
22
33
------------------------
```



# @repository

@Repository和@Controller、@Service、@Component的作用差不多，都是把对象交给spring管理。@Repository用在持久层的接口上，这个注解是将接口的一个实现类交给spring管理



# @PathVariable 

介绍：

@PathVariable 映射 URL 绑定的占位符

- 带占位符的 **URL** 是 **Spring3.0** 新增的功能，**该功能在SpringMVC 向 REST 目标挺进发展过程中具有里程碑的意义**
- 通过 **@PathVariable** 可以将 **URL** 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {**xxx**} 占位符可以通过@PathVariable(“**xxx**“)  绑定到操作方法的入参中。
- 主要是根据请求方法进行类的区别



例子：

//@PathVariable可以用来映射URL中的占位符到目标方法的参数中
@RequestMapping("/testPathVariable/{id}")
  public String testPathVariable(@PathVariable("id") Integer id)
  {
    System.out.println("testPathVariable:"+id);
    return SUCCESS;
  }





REST

- REST：即 Representational State Transfer。（资源）表现层状态转化。是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用
- 资源（**Resources**）：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 **URI** 。要获取这个资源，访问它的URI就可以，因此 **URI** 即为每一个资源的独一无二的识别符。
- 表现层（**Representation**）：把资源具体呈现出来的形式，叫做它的表现层（**Representation**）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式。
- 状态转化（**State Transfer**）：每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生**“**状态转化**”**（**State Transfer**）。而这种转化是建立在表现层之上的，所以就是 **“**表现层状态转化**”**。具体说，就是 **HTTP** 协议里面，四个表示操作方式的动词：**GET**、**POST**、**PUT**、**DELETE**。它们分别对应四种基本操作：**GET** 用来获取资源，**POST** 用来新建资源，**PUT** 用来更新资源，**DELETE** 用来删除资源。

**示例：** 
\- /order/1 HTTP **GET** ：得到 id = 1 的 order 
\- /order/1 HTTP **DELETE**：删除 id = 1的 order 
\- /order/1 HTTP **PUT**：更新id = 1的 order 
\- /order HTTP **POST**：新增 order

###@RequestParam：

将请求参数绑定到你控制器的方法参数上

