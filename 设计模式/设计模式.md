## 面向对象设计原则

> 在进行软件开发时，不仅需要将基本的业务完成，还要考虑整个项目的==可维护性==和==可复用性==。
>
> 因此在编写代码时，应该尽可能的规范，不然随着项目的不断扩大，整体结构只会越来越遭。
>
> 为了避免这种情况的发生，应该尽量遵守==面向对象设计原则==。

1. **单一职责原则：**一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。==(类的划分要明确，专门的类做专门的事，不能所有的东西都写在一个类中)==
2. **开闭原则：**软件实体应当对扩展开放，对修改关闭。==（一个接口的具体实现最好的交由调用者，这样可以针对不同的业务扩展出不同的实现，灵活多变）==
3. **里式替换原则：**所有引用基类的地方必须能透明地使用其子类的对象。==（子类继承，不对父类方法进行重写，因为重写会覆盖父类方法，子类可以扩展自己的方法）==
4. **依赖倒转原则：**高层模块不应依赖于底层模块，它们都应该依赖抽象。抽象不应依赖于细节，细节应该依赖于抽象。==（spring的思想：解耦，将接口和实现类分离，便于业务变更和扩展）==
5. **接口隔离原则：**客户端不应依赖那些它不需要的接口。==（将接口细化，在继承接口时尽量不要出现此类不需要的方法）==
6. **合成复用原则：**优先使用对象组合，而不是通过继承来达到复用的目的。==（在使用它类对象方法时，尽量使用调用，而不是继承，继承的耦合性太高）==
7. **迪米特法则：**每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。==（在传参时，尽量避免过程冗余，比如能使用string的，就不要使用user.getName()）==

## 设计模式分类

![设计模式分类](D:\Study\Learning-record\设计模式\设计模式分类.png)

## 单例模式

> 什么是单例模式

1. 构造方法私有化，创建唯一实例
2. 静态属性指向实例
3. 提供静态方法，返回静态属性

> 单例模式特点

1. 单例类只能有一个实例
2. 单例类必须自己创建自己的唯一实例
3. 单例类必须给其他类提供获取实例的方法

> 使用场景

1. 要求生产唯一序列号。

2. Web 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。

3. 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。

### 饿汉式

在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的

如果在构造方法里写了性能消耗较大，耗时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿

```java
//饿汉式单例
public class Test {
    private Test() {
        
    }
    
    private final static Test TEST = new Test();
    
    public static Test getInstance() {
        return TEST;
    }
}
```

### DCL懒汉式

在调用getInstance时才创建实例对象

使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。

```java
//DCL懒汉式单例
public class Test {

    private Test() {

    }

    //volatile关键字 1.保证变量的内存可见性 2.不保证原子性 3.禁止指令重排序
    private volatile static Test test = null;

    //双重检测锁机制
    public static Test getInstance() {
        //第一次判断，实例为空，就有获取锁的资格
        if (test == null) {
            //锁住类，保证同一时间只能有一条线程进行操作
            synchronized (Test.class) {
                if (test == null) {
                   test = new Test();
                }
            }
        }
        return test;
    }
}
```

前面的写法尽管已经考虑得很完善，但还是忽略了**反射**。反射可以直接获取类，调用`newInstance`来生成对象实例

枚举类本质上也是一个类，在类的基础上进行了一些约束，**反射**无法破坏枚举类，所以我们使用枚举类来实现单例

```java
public enum Singleton {
    /**
     * 单例对象
     */
    INSTANCE
}
```

## 工厂模式

> 概述

在工厂模式中，创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

如果需要创建一个对象，最简单的方式就是直接 `new`一个。而工厂模式代替了传统的直接 new 的形式，那么为什么要替代呢？**如果所有的对象都通过 new 的方式去创建，那么当程序中大量使用此对象时，突然有一天这个对象的构造方法或是类名发生了修改，那就得逐个去进行修改。**

根据**迪米特法则**，应该尽可能地少与其他类进行交互，所以可以将那些需要频繁出现的对象创建，封装到一个工厂类中。当需要对象时，直接调用工厂类中的工厂方法来生成对象，这样，就算类出现了变动，只需要修改工厂中的代码即可，而不是大面积地进行修改。同时，可能某些对象的创建并不只是一个 new 就可以搞定，可能还需要更多的步骤来准备构造方法需要的参数。

> 使用场景

1. 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。

2. 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。

3. 设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。

### 简单工厂模式

> 通过一个工厂，生产相同类型的不同产品

![简单工厂UML](D:\Study\Learning-record\设计模式\简单工厂UML.png)

- 车的抽象类

```java
public interface Car{
    void name();
}
```

- 奔驰实现类

```java
public class BenChi extends Car{
    @Override
    public void name() {
        System.out.println("奔驰");
    }
}
```

- 宝马实现类

```java
public class BaoMa extends Car{
    @Override
    public void name() {
        System.out.println("宝马");
    }
}
```

- 车工厂

```java
public class CarFactory {
    public static Car getCar(String name){
        switch (name){
            case "奔驰": 
                Car car = new BenChi();
                //构建一些奔驰车辆的基础信息等等
                //此处省略代码1w行
                //......
                return car;
            case "宝马": 
                Car car = new BaoMa();
                //构建一些宝马车辆的基础信息等等
                //此处省略代码1w行
                //......
                return car;
            default: return null;
        }
    }
}
```

- 调用

```java
public class Test {
    public static void main(String[] args) {
        Car car1 = new CarFactory().getCar("宝马");
        Car car2 = new CarFactory().getCar("奔驰");

        car1.name();
        car2.name();
    }
}
```

### 工厂方法模式

> 同类型的不同产品都有各自的工厂进行专门的生产

==这样写有利于横向扩展，当有新的类时，我们加上它的工厂即可。但是，这样写会徒增一倍的代码量，因为每一个实现类都有自己的专属工厂。==

![工厂方法UML](D:\Study\Learning-record\设计模式\工厂方法UML.png)

- 工厂接口

```java
public interface CarFactory {
    Car getCar();
}
```

- 奔驰车工厂

```java
public class BenChiFactory implements CarFactory{
    @Override
    public Car getCar() {
        Car car = new BenChi();
        //构建一些奔驰车辆的基础信息等等
        //此处省略代码1w行
        //......
        return car;
    }
}
```

- 宝马车工厂

```java
public class BaoMaFactory implements CarFactory{
    @Override
    public Car getCar() {
        Car car = new BaoMa();
        //构建一些宝马车辆的基础信息等等
        //此处省略代码1w行
        //......
        return car;
    }
}
```

- 调用

```java
public class Test {
    public static void main(String[] args) {
        Car car1 = new BenChiFactory().getCar();
        Car car2 = new BaoMaFactory().getCar();

        car1.name();
        car2.name();
    }
}
```

### 抽象工厂模式

> 概述

**抽象工厂模式**是围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类，每个生成的工厂都能按照工厂模式提供对象。前面的**工厂模式**通过定义顶层抽象工厂类，通过继承的方式，针对于每一个产品都提供一个工厂类用于创建。

不过这种模式只适用于简单对象，当需要生产许多个产品族的时候，这种模式就有点乏力了

比如小米的产品线上有小米手机、小米平板等，华为的产品线上也有华为手机、华为平板。如果按照之前的工厂模式来进行设计，那就需要单独设计 9 个工厂来生产上面这些产品，显然这样就比较浪费时间的。

这时可以使用抽象工厂模式，将多个产品都放在一个工厂中进行生成，按不同的产品族进行划分。比如小米，那么就创建一个小米工厂，这个工厂里面可以生产整条产品线上的内容，包括小米手机、小米平板等。

> 使用场景

1. QQ 换皮肤，一整套一起换。

2. 生成不同操作系统的程序。

![抽象工厂UML](D:\Study\Learning-record\设计模式\抽象工厂UML.png)

- 创建产品接口

```java
/**
 * 手机
 */
public interface Phone {
    /**
     * 打电话
     */
    void call();
}
```

```java
/**
 * 平板
 */
public interface Pad {
    /**
     * 看视频
     */
    void video();
}
```

- 定义具体产品

```java
/**
 * 小米手机
 */
public class XiaoMiPhone implements Phone {
    @Override
    public void call() {
        System.out.println("小米手机打电话");
    }
}
```

```java
/**
 * 小米平板
 */
public class XiaoMiPad implements Pad {
    @Override
    public void video() {
        System.out.println("小米平板看视频");
    }
}
```

```java
/**
 * 华为手机
 */
public class HuaWeiPhone implements Phone {
    @Override
    public void call() {
        System.out.println("华为手机打电话");
    }
}
```

```java
/**
 * 华为平板
 */
public class HuaWeiPad implements Pad {
    @Override
    public void video() {
        System.out.println("华为平板看视频");
    }
}
```

- 创建抽象工厂

```java
/**
 * 抽象工厂
 */
public abstract class AbstractFactory {
    /**
     * 获取手机
     * @return 手机对象
     */
    public abstract Phone getPhone();
    /**
     * 获取平板
     * @return 平板对象
     */
    public abstract Pad getPad();
}
```

- 创建品牌工厂

```java
/**
 * 小米工厂
 */
public class XiaoMiFactory extends AbstractFactory{
    @Override
    public Phone getPhone() {
        return new XiaoMiPhone();
    }
    @Override
    public Pad getPad() {
        return new XiaoMiPad();
    }
}
```

```java
/**
 * 华为工厂
 */
public class HuaWeiFactory extends AbstractFactory {
    @Override
    public Phone getPhone() {
        return new HuaWeiPhone();
    }
    @Override
    public Pad getPad() {
        return new HuaWeiPad();
    }
}
```

- 调用

```java
// 小米手机
Phone xiaomiPhone = new XiaoMiFactory().getPhone();
// 华为手机
Phone huaweiPhone = new HuaWeiFactory().getPhone();
// 小米平板
Pad xiaoMiPad = new XiaoMiFactory().getPad();
// 华为平板
Pad huaweiPad = new HuaWeiFactory().getPad();
// 输出测试
xiaomiPhone.call();
huaweiPhone.call();
xiaoMiPad.video();
huaweiPad.video();
```

## 建造者模式

> 概述

建造者模式使用多个简单的对象一步一步构建成一个复杂的对象。（一般就是在构建较复杂类的时候才会用到建造者模式）

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

经常使用的 `StringBuiler` 就是建造者模式的典型实现。

> 使用场景

1. 需要生成的对象具有复杂的内部结构。

2. 需要生成的对象内部属性本身相互依赖。

### 普通实现

- 产品

```java
public class Product {
    /**
     * 快餐 A 默认为汉堡
     */
    private String BuildA = "汉堡";
    /**
     * 快餐 B 默认为可乐
     */
    private String BuildB = "可乐";
    /**
     * 快餐 C 默认为薯条
     */
    private String BuildC = "薯条";
    /**
     * 快餐 D 默认为甜点
     */
    private String BuildD = "甜点";
    
    public String getBuildA() {
        return BuildA;
    }
    public void setBuildA(String buildA) {
        BuildA = buildA;
    }
    public String getBuildB() {
        return BuildB;
    }
    public void setBuildB(String buildB) {
        BuildB = buildB;
    }
    public String getBuildC() {
        return BuildC;
    }
    public void setBuildC(String buildC) {
        BuildC = buildC;
    }
    public String getBuildD() {
        return BuildD;
    }
    public void setBuildD(String buildD) {
        BuildD = buildD;
    }
    @Override
    public String toString() {
        return "Product{" +
                "BuildA='" + BuildA + '\'' +
                ", BuildB='" + BuildB + '\'' +
                ", BuildC='" + BuildC + '\'' +
                ", BuildD='" + BuildD + '\'' +
                '}';
    }
}
```

- 厨房（建造者）

```java
public abstract class Kitchen {
    /**
     * 制作快餐 A
     * @param msg 快餐名称
     * @return 快餐
     */
    abstract Kitchen builderA(String msg);
    /**
     * 制作快餐 B
     * @param msg 快餐名称
     * @return 快餐
     */
    abstract Kitchen builderB(String msg);
    /**
     * 制作快餐 C
     * @param msg 快餐名称
     * @return 快餐
     */
    abstract Kitchen builderC(String msg);
    /**
     * 制作快餐 D
     * @param msg 快餐名称
     * @return 快餐
     */
    abstract Kitchen builderD(String msg);
    /**
     * 获取产品
     * @return 产品
     */
    abstract Product getProduct();
}
```

- 服务员（传递者）

```java
public class Waiter extends Kitchen {
    private Product product;
    public Waiter(){
        product = new Product();
    }
    @Override
    Kitchen builderA(String msg) {
        product.setBuildA(msg);
        return this;
    }
    @Override
    Kitchen builderB(String msg) {
        product.setBuildB(msg);
        return this;
    }
    @Override
    Kitchen builderC(String msg) {
        product.setBuildC(msg);
        return this;
    }
    @Override
    Kitchen builderD(String msg) {
        product.setBuildD(msg);
        return this;
    }
    @Override
    Product getProduct() {
        return product;
    }
}
```

- 客户

```java
// 叫服务员
Waiter waiter = new Waiter();

//可以选择套餐，省事，直接告诉服务员要套餐即可
Product product1 = waiter.getProduct();
System.out.println(product1);

//也可以自己点餐，点了哪些上哪些
//链式编程
Product product2 = waiter
    .builderA("炸鸡")
    .builderB("雪碧")
    .builderC(null)
    .builderD(null)
    .getProduct();
System.out.println(product2);
```

### 指挥者实现

> 在工地建筑时，除了建造本身，建造的顺序也非常重要，因此工地上一般都会有一个指挥者来决定建造的顺序。

![建造者UML类图](D:\Study\Learning-record\设计模式\建造者UML类图.jpg)

- 定义一栋楼（产品）

```java
/**
 * 一栋楼（产品）
 */
public class Product {
    /**
     * 地基
     */
    private String productA;
    /**
     * 主体
     */
    private String productB;
    /**
     * 粉刷
     */
    private String productC;
    /**
     * 绿化
     */
    private String productD;
    public String getProductA() {
        return productA;
    }
    public void setProductA(String productA) {
        this.productA = productA;
    }
    public String getProductB() {
        return productB;
    }
    public void setProductB(String productB) {
        this.productB = productB;
    }
    public String getProductC() {
        return productC;
    }
    public void setProductC(String productC) {
        this.productC = productC;
    }
    public String getProductD() {
        return productD;
    }
    public void setProductD(String productD) {
        this.productD = productD;
    }
    @Override
    public String toString() {
        return "Product{" +
                "productA='" + productA + '\'' +
                ", productB='" + productB + '\'' +
                ", productC='" + productC + '\'' +
                ", productD='" + productD + '\'' +
                '}';
    }
}
```

- 包工头（抽象建造者）

```java
/**
 * 包工头（抽象建造者）
 * @author yifan
 */
public abstract class Builder {
    /**
     * 打地基
     */
    abstract void buildA();
    /**
     * 建主体
     */
    abstract void buildB();
    /**
     * 去粉刷
     */
    abstract void buildC();
    /**
     * 搞绿化
     */
    abstract void buildD();
    /**
     * 建一栋楼
     * @return 一栋楼
     */
    abstract Product getProduct();
}
```

- 工人（实际建造者）

```java
/**
 * 工人（实际建造者）
 */
public class Worker extends Builder{
    private Product product;
    public Worker() {
        // 指定要建设的楼
        product = new Product();
    }
    @Override
    void buildA() {
        product.setProductA("地基");
        System.out.println("地基");
    }
    @Override
    void buildB() {
        product.setProductB("主体");
        System.out.println("主体");
    }
    @Override
    void buildC() {
        product.setProductC("粉刷");
        System.out.println("粉刷");
    }
    @Override
    void buildD() {
        product.setProductD("绿化");
        System.out.println("绿化");
    }
    @Override
    Product getProduct() {
        return product;
    }
}
```

- 施工调度员（指挥者）

```java
/**
 * 施工调度员（指挥者）
 */
public class Director {
    /**
     * 指挥包工头按照顺序建楼
     * @param builder 包工头
     * @return 楼
     */
    public Product build(Builder builder){
        builder.buildA();
        builder.buildB();
        builder.buildC();
        builder.buildD();
        return builder.getProduct();
    }
}
```

- 建楼

```java
// 施工调度员指挥包工头，包工头找到具体的工人按照施工调度员指定的顺序建造
new Director().build(new Worker());
```

## 原型模式

> 概述

**原型模式实际上就是对象的拷贝。**

原型模式使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。也就是说，原型对象作为模板，通过克隆操作，来产生更多的对象，就像细胞的复制一样。

原型模式的拷贝分为**浅拷贝**和**深拷贝**。

在 Java 中，就可以实现 Cloneable 接口提供的拷贝机制，来实现原型模式

> 使用场景

1. 资源优化场景。

2. 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。

3. 性能和安全要求的场景。

4. 通过 `new` 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。

5. 一个对象多个修改者的场景。

6. 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。

7. 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 `clone` 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，可以随手拿来使用。

![拷贝](D:\Study\Learning-record\设计模式\拷贝.jpg)

### 浅拷贝

> 对于类中**基本数据类型**，会直接复制值给拷贝对象；对于类中**引用类型**，只会复制对象的地址，而实际上指向的还是原来的那个对象。
>
> 浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。

- 需要克隆的对象需要继承`Cloneable`接口，重写`clone`方法

```java
public class Address implements Cloneable{
    private String name;
    // 省略构造函数、Getter&Setter方法
    @Override
    public Address clone() {
        try {
            return (Address) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}

public class Person implements Cloneable {
    private Address address;
    // 省略构造函数、Getter&Setter方法
    @Override
    public Person clone() {
        try {
            Person person = (Person) super.clone();
            return person;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
```

- 测试

```java
Person person1 = new Person(new Address("武汉"));
Person person1Copy = person1.clone();
// true
System.out.println(person1.getAddress() == person1Copy.getAddress());
```

### 深拷贝

> 深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

- 简单改写`clone`方法

```java
@Override
public Person clone() {
    try {
        Person person = (Person) super.clone();
        person.setAddress(person.getAddress().clone());
        return person;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}
```

- 再次测试

```java
Person person1 = new Person(new Address("武汉"));
Person person1Copy = person1.clone();
// false
System.out.println(person1.getAddress() == person1Copy.getAddress());
```

## 适配器模式

> 概述

**结构型**模式关注如何将现有的类或对象组织在一起形成更加强大的结构。

在生活中，我们经常遇到这样的一个问题：轻薄笔记本通常只有 type-c 或者 usb-a 接口，没有网口。但日常使用中是往往需要连接网口上网的，这时想到的第一个解决方案，就是去买一个**转接头**或者**扩展坞**。它们可以将 type-c 或者 usb-a 转换为其他类型的接口供我们使用，实际上这就是一种**适配器模式**。

我们常用的充电头，为什么叫**电源适配器**呢？传统的供电是 220V 交流电，但是手机可能只需要 5V 的电压进行充电，所以虽然现在有电，但是不能直接充。也不可能让电力公司专门为我们提供一个 5V 的直流电使用，这时电源适配器就开始发挥作用了。比如苹果的祖传 5V1A 充电头，实际上就是将 220V 交流电转换为 5V 的直流电进行传输。这样就相当于在 220V 交流电和手机之间，做了一个**适配器**的角色。

适配器模式分为**类适配器**和**对象适配器。**

> 使用场景

有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。

### 类适配器（不推荐）

> 这种实现方式需要占用一个继承位。如果此时 NetToUsb 不是接口而是抽象类的话，由于 Java 不支持多继承，就无法实现了。

- 电脑

```java
public class Computer {
    /**
     * 电脑需要连接上转换器才可以上网
     *
     * @param adapter 转接器
     */
    public void connect(NetToUsb adapter) {
        // 上网的具体实现，找一个转接头
        adapter.connectNetLine();
    }
}
```

- 网线

```java
public class NetLine {
    /**
     * 上网
     */
    public void online(){
        System.out.println("连接网线上网");
    }
}
```

- 适配器接口

```java
public interface NetToUsb {
    /**
     * 处理请求，usb -> 网线
     */
    void connectNetLine();
}
```

- 适配器实现

```java
public class ClassAdapter extends NetLine implements NetToUsb {
    @Override
    public void connectNetLine() {
        // 可以上网了
        super.online();
    }
}
```

- 使用

```java
// 电脑
Computer computer = new Computer();
// 转接器已经插上网线
ClassAdapter adapter = new ClassAdapter();
// 电脑连接转接器，成功上网
computer.connect(adapter);
```

### 对象适配器

- 适配器

```java
public class ObjectAdapter implements NetToUsb {
    /**
     * 网线
     */
    private NetLine netLine;
    //手动设置适配器类别，更加灵活
    public ObjectAdapter(NetLine netLine) {
        this.netLine = netLine;
    }
    @Override
    public void connectNetLine() {
        // 可以上网了
        netLine.online();
    }
}
```

- 使用

```java
public class ObjectAdapterTest {
    @Test
    public void test() {
        // 电脑
        Computer computer = new Computer();
        // 网线
        NetLine netLine = new NetLine();
        // 转接器插上网线
        ObjectAdapter adapter = new ObjectAdapter(netLine);
        // 电脑连接转接器，成功上网
        computer.connect(adapter);
    }
}
```

## 桥接模式

> 概述

桥接模式是将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为**柄体**（Handle and Body）模式或**接口**（Interface）模式。

比如需要创建电脑对象，市面上的电脑非常多，**品牌**有华为、苹果、联想等等，**类型**有台式、笔记本、平板等等。如果给每个品牌的每个类型的电脑都创建一个对象，那是十分繁琐的，而且非常不方便扩展。试想如果增加了一个**品牌**或者**类型**，那就需要增加大量的对象，这无疑是笨重和低效的。

这时我们会想，如果给**品牌**和**类型**分别设置一个维度，再将这两个维度组合起来就得到了一个对象，这样只需要定义所有的**品牌**和所有的**类型**即可，如果需要增加，只需要增加一个**品牌**或者**类型**即可。

> 使用场景

1. 如果一个系统需要在构建的抽象角色和具体角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。抽象角色和具体角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象子类的对象和一个具体类的对象进行组合，即系统需要对抽象角色和具体角色进行动态耦合。

2. 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。

3. 虽然在系统中使用继承是没有问题的，但是由于抽象角色和具体角色需要独立变化，设计要求需要独立管理这两者。对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

4. Java 语言通过 Java 虚拟机与操作系统的桥接实现了平台的无关性。

5. AWT 中的 Peer 架构。

6. JDBC 驱动程序。

![桥接模式](D:\Study\Learning-record\设计模式\桥接模式.jpg)

- 品牌接口

```java
public interface Brand {
    /**
     * 名称
     */
    String name();
}
```

- 品牌实现类

```java
/**
 * 联想
 */
public class Lenovo implements Brand {
    @Override
    public String name() {
        return "联想";
    }
}
```

```java
/**
 * 苹果
 */
public class Apple implements Brand {
    @Override
    public String name() {
        return "苹果";
    }
}
```

```java
/**
 * 戴尔
 */
public class Dell implements Brand {
    @Override
    public String name() {
        return "戴尔";
    }
}
```

- 电脑抽象类

这里不使用接口是因为电脑附带默认品牌属性，需要构造

```java
public abstract class Computer {
    /**
     * 品牌
     * <p>因为需要提供继承类使用，这里定义为 protected
     */
    protected Brand brand;
    public Computer(Brand brand) {
        this.brand = brand;
    }
    /**
     * 获取电脑名称，留给子类实现
     */
    public abstract String name();
}
```

- 电脑实现类

```java
/**
 * 台式
 */
public class Desktop extends Computer {
    public Desktop(Brand brand) {
        super(brand);
    }
    @Override
    public String name() {
        return super.brand.name() + "台式";
    }
}
```

```java
/**
 * 笔记本
 */
public class Laptop extends Computer {
    public Laptop(Brand brand) {
        super(brand);
    }
    @Override
    public String name() {
        return super.brand.name() + "笔记本";
    }
}
```

- 组合

```java
// 苹果笔记本
Computer computer = new Laptop(new Apple());
System.out.println(computer.name());
// 华为台式机
Computer computer1 = new Desktop(new HuaWei());
System.out.println(computer1.name());
```

## 代理模式

> 概述

**代理模式**就是一个代理对象来间接访问对象，常用于无法直接访问某个对象或访问某个对象不方便的情况。

实际上代理在生活中处处都存在，比如房屋中介就是代理，Apple 的授权经销商就是代理，访问国外网站所用的代理服务器也是代理，Spring 框架的 AOP 也是通过代理模式实现的。

这些代理都有一个共同特点，就是使用的**一致性**和中间环节的**透明性**，也就是说找代理做的事情需要与找对象本身做的事情是一样的，只是中间环节隐藏了而已。

代理模式分为**静态代理**和**动态代理**。

### 静态代理

静态代理包含以下角色：

- **动作** : 一般使用接口或者抽象类来实现。
- **真实角色** : 被代理的角色。
- **代理角色** : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作。
- **客户** : 使用代理角色来进行一些操作。

> 示例1：房屋出租-中介

- 租赁操作

```java
/**
 * 租赁操作
 */
public interface Rent {
    void rentHouse();
}
```

- 房东出租房屋（真实对象）

```java
public class Landlord implements Rent{
    @Override
    public void rentHouse() {
        System.out.println("房东出租房子");
    }
}
```

- 中介出租房屋（代理对象）

```java
public class Intermediary implements Rent{
    private Landlord landlord;
    public Intermediary() {
    }
    //注入真实对象
    public Intermediary(Landlord landlord) {
        this.landlord = landlord;
    }
    @Override
    public void rentHouse() {
        // 看房
        seeHouse();
        // 签合同
        contract();
        // 租房
        landlord.rentHouse();
        // 收取费用
        toll();
    }
    /**
     * 看房
     */
    public void seeHouse() {
        System.out.println("中介带你看房");
    }
    /**
     * 签合同
     */
    public void contract() {
        System.out.println("签租赁合同");
    }
    /**
     * 收取费用
     */
    public void toll() {
        System.out.println("收中介费");
    }
}
```

> 示例2：CRUD操作添加日志

使用代理模式不会破坏原有类

- Service接口

```java
public interface UserService {
    /**
     * 新增
     */
    public void add();
    /**
     * 删除
     */
    public void delete();
    /**
     * 修改
     */
    public void update();
    /**
     * 查询
     */
    public void query();
}
```

- ServiceImpl

```java
public class UserServiceImpl implements UserService {
    @Override
    public void add() {
        System.out.println("新增了一个用户");
    }
    @Override
    public void delete() {
        System.out.println("删除了一个用户");
    }
    @Override
    public void update() {
        System.out.println("修改了一个用户");
    }
    @Override
    public void query() {
        System.out.println("查询了一个用户");
    }
}
```

- 代理类

对于每一个操作都添加了日志打印

```java
public class UserServiceProxy implements UserService {
    /**
     * 用户服务实现类
     */
    private UserServiceImpl userService;
    public void setUserService(UserServiceImpl userService) {
        this.userService = userService;
    }
    @Override
    public void add() {
        log("add");
        userService.add();
    }
    @Override
    public void delete() {
        log("delete");
        userService.delete();
    }
    @Override
    public void update() {
        log("update");
        userService.update();
    }
    @Override
    public void query() {
        log("query");
        userService.query();
    }
    /**
     * 打印日志
     *
     * @param msg 消息
     */
    public void log(String msg) {
        System.out.println("使用了" + msg + "方法");
    }
}
```

- 使用代理

```java
// 用户服务实现类
UserServiceImpl userService = new UserServiceImpl();
// 用户服务代理类
UserServiceProxy proxy = new UserServiceProxy();
// 代理用户服务
proxy.setUserService(userService);
// 代理实现新增
proxy.add();
// 代理实现删除
proxy.delete();
// 代理实现修改
proxy.update();
// 代理实现查询
proxy.query();
```

### 动态代理

- 动态代理和静态代理角色一样
- 动态代理的代理类是动态生成的，不是直接写好的
- 动态代理分为两大类：
  - 基于接口的动态代理：JDK动态代理
  - 基于类的动态代理：cglib动态代理

JDK动态代理基于两个核心类`Proxy`和`InvocationHandler`

- Service接口

```java
public interface UserService {
    /**
     * 新增
     */
    public void add();
    /**
     * 删除
     */
    public void delete();
    /**
     * 修改
     */
    public void update();
    /**
     * 查询
     */
    public void query();
}
```

- ServiceImpl

```java
public class UserServiceImpl implements UserService {
    @Override
    public void add() {
        System.out.println("新增了一个用户");
    }
    @Override
    public void delete() {
        System.out.println("删除了一个用户");
    }
    @Override
    public void update() {
        System.out.println("修改了一个用户");
    }
    @Override
    public void query() {
        System.out.println("查询了一个用户");
    }
}
```

- 用于动态生成代理类的一个工具类

```java
public class ProxyInvocationHandler implements InvocationHandler {
    private Object target;
 
    public void setTarget(Object target) {
        this.target = target;
    }
 
    //使用Proxy的静态方法生成代理类
    //参数一：类加载器
    //参数二：需要代理的接口
    //参数三：InvocationHandler处理器
    //重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),
                target.getClass().getInterfaces(),this);
    }
 
    // proxy : 代理类
    // method : 代理类的调用处理程序的方法对象.
    // 处理代理实例上的方法调用并返回结果
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        log(method.getName());
        //核心：本质利用反射实现！
        Object result = method.invoke(target, args);
        return result;
    }
 
    //用代理添加日志功能
    public void log(String methodName) {
        System.out.println("调用了" + methodName + "方法");
    }
}
```

- 动态生成代理类并使用

```java
public class Test {
    public static void main(String[] args) {
        //真实对象
        UserServiceImpl userService = new UserServiceImpl();
        //代理对象的调用处理程序
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        pih.setTarget(userService); //设置要代理的对象
        UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！
        proxy.add();
    }
}
```

