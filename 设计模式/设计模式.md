## 面向对象设计原则

> 在进行软件开发时，不仅需要将基本的业务完成，还要考虑整个项目的==可维护性==和==可复用性==。
>
> 因此在编写代码时，应该尽可能的规范，不然随着项目的不断扩大，整体结构只会越来越遭。
>
> 为了避免这种情况的发生，应该尽量遵守==面向对象设计原则==。

1. **单一职责原则：**一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。==(类的划分要明确，专门的类做专门的事，不能所有的东西都写在一个类中)==
2. **开闭原则：**软件实体应当对扩展开放，对修改关闭。==（一个接口的具体实现最好的交由调用者，这样可以针对不同的业务扩展出不同的实现，灵活多变）==
3. **里式替换原则：**所有引用基类的地方必须能透明地使用其子类的对象。==（子类继承，不对父类方法进行重写，因为重写会覆盖父类方法，子类可以扩展自己的方法）==
4. **依赖倒转原则：**高层模块不应依赖于底层模块，它们都应该依赖抽象。抽象不应依赖于细节，细节应该依赖于抽象。==（spring的思想：解耦，将接口和实现类分离，便于业务变更和扩展）==
5. **接口隔离原则：**客户端不应依赖那些它不需要的接口。==（将接口细化，在继承接口时尽量不要出现此类不需要的方法）==
6. **合成复用原则：**优先使用对象组合，而不是通过继承来达到复用的目的。==（在使用它类对象方法时，尽量使用调用，而不是继承，继承的耦合性太高）==
7. **迪米特法则：**每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。==（在传参时，尽量避免过程冗余，比如能使用string的，就不要使用user.getName()）==

## 设计模式分类

![设计模式分类](D:\Study\Learning-record\设计模式\设计模式分类.png)

## 单例模式

> 什么是单例模式

1. 构造方法私有化，创建唯一实例
2. 静态属性指向实例
3. 提供静态方法，返回静态属性

> 单例模式特点

1. 单例类只能有一个实例
2. 单例类必须自己创建自己的唯一实例
3. 单例类必须给其他类提供获取实例的方法

> 使用场景

1. 要求生产唯一序列号。

2. Web 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。

3. 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。

### 饿汉式

在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的

如果在构造方法里写了性能消耗较大，耗时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿

```java
//饿汉式单例
public class Test {
    private Test() {
        
    }
    
    private final static Test TEST = new Test();
    
    public static Test getInstance() {
        return TEST;
    }
}
```

### DCL懒汉式

在调用getInstance时才创建实例对象

使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。

```java
//DCL懒汉式单例
public class Test {

    private Test() {

    }

    //volatile关键字 1.保证变量的内存可见性 2.不保证原子性 3.禁止指令重排序
    private volatile static Test test = null;

    //双重检测锁机制
    public static Test getInstance() {
        //第一次判断，实例为空，就有获取锁的资格
        if (test == null) {
            //锁住类，保证同一时间只能有一条线程进行操作
            synchronized (Test.class) {
                if (test == null) {
                   test = new Test();
                }
            }
        }
        return test;
    }
}
```

前面的写法尽管已经考虑得很完善，但还是忽略了**反射**。反射可以直接获取类，调用`newInstance`来生成对象实例

枚举类本质上也是一个类，在类的基础上进行了一些约束，**反射**无法破坏枚举类，所以我们使用枚举类来实现单例

```java
public enum Singleton {
    /**
     * 单例对象
     */
    INSTANCE
}
```

## 工厂模式

> 概述

在工厂模式中，创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

如果需要创建一个对象，最简单的方式就是直接 `new`一个。而工厂模式代替了传统的直接 new 的形式，那么为什么要替代呢？**如果所有的对象都通过 new 的方式去创建，那么当程序中大量使用此对象时，突然有一天这个对象的构造方法或是类名发生了修改，那就得逐个去进行修改。**

根据**迪米特法则**，应该尽可能地少与其他类进行交互，所以可以将那些需要频繁出现的对象创建，封装到一个工厂类中。当需要对象时，直接调用工厂类中的工厂方法来生成对象，这样，就算类出现了变动，只需要修改工厂中的代码即可，而不是大面积地进行修改。同时，可能某些对象的创建并不只是一个 new 就可以搞定，可能还需要更多的步骤来准备构造方法需要的参数。

> 使用场景

1. 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。

2. 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。

3. 设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。

### 简单工厂模式

> 通过一个工厂，生产相同类型的不同产品

![简单工厂UML](D:\Study\Learning-record\设计模式\简单工厂UML.png)

- 车的抽象类

```java
public interface Car{
    void name();
}
```

- 奔驰实现类

```java
public class BenChi extends Car{
    @Override
    public void name() {
        System.out.println("奔驰");
    }
}
```

- 宝马实现类

```java
public class BaoMa extends Car{
    @Override
    public void name() {
        System.out.println("宝马");
    }
}
```

- 车工厂

```java
public class CarFactory {
    public static Car getCar(String name){
        switch (name){
            case "奔驰": 
                Car car = new BenChi();
                //构建一些奔驰车辆的基础信息等等
                //此处省略代码1w行
                //......
                return car;
            case "宝马": 
                Car car = new BaoMa();
                //构建一些宝马车辆的基础信息等等
                //此处省略代码1w行
                //......
                return car;
            default: return null;
        }
    }
}
```

- 调用

```java
public class Test {
    public static void main(String[] args) {
        Car car1 = new CarFactory().getCar("宝马");
        Car car2 = new CarFactory().getCar("奔驰");

        car1.name();
        car2.name();
    }
}
```

### 工厂方法模式

> 同类型的不同产品都有各自的工厂进行专门的生产

==这样写有利于横向扩展，当有新的类时，我们加上它的工厂即可。但是，这样写会徒增一倍的代码量，因为每一个实现类都有自己的专属工厂。==

![工厂方法UML](D:\Study\Learning-record\设计模式\工厂方法UML.png)

- 工厂接口

```java
public interface CarFactory {
    Car getCar();
}
```

- 奔驰车工厂

```java
public class BenChiFactory implements CarFactory{
    @Override
    public Car getCar() {
        Car car = new BenChi();
        //构建一些奔驰车辆的基础信息等等
        //此处省略代码1w行
        //......
        return car;
    }
}
```

- 宝马车工厂

```java
public class BaoMaFactory implements CarFactory{
    @Override
    public Car getCar() {
        Car car = new BaoMa();
        //构建一些宝马车辆的基础信息等等
        //此处省略代码1w行
        //......
        return car;
    }
}
```

- 调用

```java
public class Test {
    public static void main(String[] args) {
        Car car1 = new BenChiFactory().getCar();
        Car car2 = new BaoMaFactory().getCar();

        car1.name();
        car2.name();
    }
}
```

### 抽象工厂模式

> 概述

**抽象工厂模式**是围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类，每个生成的工厂都能按照工厂模式提供对象。前面的**工厂模式**通过定义顶层抽象工厂类，通过继承的方式，针对于每一个产品都提供一个工厂类用于创建。

不过这种模式只适用于简单对象，当需要生产许多个产品族的时候，这种模式就有点乏力了

比如小米的产品线上有小米手机、小米平板等，华为的产品线上也有华为手机、华为平板。如果按照之前的工厂模式来进行设计，那就需要单独设计 9 个工厂来生产上面这些产品，显然这样就比较浪费时间的。

这时可以使用抽象工厂模式，将多个产品都放在一个工厂中进行生成，按不同的产品族进行划分。比如小米，那么就创建一个小米工厂，这个工厂里面可以生产整条产品线上的内容，包括小米手机、小米平板等。

> 使用场景

1. QQ 换皮肤，一整套一起换。

2. 生成不同操作系统的程序。

![抽象工厂UML](D:\Study\Learning-record\设计模式\抽象工厂UML.png)

- 创建产品接口

```java
/**
 * 手机
 */
public interface Phone {
    /**
     * 打电话
     */
    void call();
}
```

```java
/**
 * 平板
 */
public interface Pad {
    /**
     * 看视频
     */
    void video();
}
```

- 定义具体产品

```java
/**
 * 小米手机
 */
public class XiaoMiPhone implements Phone {
    @Override
    public void call() {
        System.out.println("小米手机打电话");
    }
}
```

```java
/**
 * 小米平板
 */
public class XiaoMiPad implements Pad {
    @Override
    public void video() {
        System.out.println("小米平板看视频");
    }
}
```

```java
/**
 * 华为手机
 */
public class HuaWeiPhone implements Phone {
    @Override
    public void call() {
        System.out.println("华为手机打电话");
    }
}
```

```java
/**
 * 华为平板
 */
public class HuaWeiPad implements Pad {
    @Override
    public void video() {
        System.out.println("华为平板看视频");
    }
}
```

- 创建抽象工厂

```java
/**
 * 抽象工厂
 */
public abstract class AbstractFactory {
    /**
     * 获取手机
     * @return 手机对象
     */
    public abstract Phone getPhone();
    /**
     * 获取平板
     * @return 平板对象
     */
    public abstract Pad getPad();
}
```

- 创建品牌工厂

```java
/**
 * 小米工厂
 */
public class XiaoMiFactory extends AbstractFactory{
    @Override
    public Phone getPhone() {
        return new XiaoMiPhone();
    }
    @Override
    public Pad getPad() {
        return new XiaoMiPad();
    }
}
```

```java
/**
 * 华为工厂
 */
public class HuaWeiFactory extends AbstractFactory {
    @Override
    public Phone getPhone() {
        return new HuaWeiPhone();
    }
    @Override
    public Pad getPad() {
        return new HuaWeiPad();
    }
}
```

- 调用

```java
// 小米手机
Phone xiaomiPhone = new XiaoMiFactory().getPhone();
// 华为手机
Phone huaweiPhone = new HuaWeiFactory().getPhone();
// 小米平板
Pad xiaoMiPad = new XiaoMiFactory().getPad();
// 华为平板
Pad huaweiPad = new HuaWeiFactory().getPad();
// 输出测试
xiaomiPhone.call();
huaweiPhone.call();
xiaoMiPad.video();
huaweiPad.video();
```

## 建造者模式

> 概述

建造者模式使用多个简单的对象一步一步构建成一个复杂的对象。（一般就是在构建较复杂类的时候才会用到建造者模式）

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

经常使用的 `StringBuiler` 就是建造者模式的典型实现。

> 使用场景

1. 需要生成的对象具有复杂的内部结构。

2. 需要生成的对象内部属性本身相互依赖。

### 普通实现

- 产品

```java
public class Product {
    /**
     * 快餐 A 默认为汉堡
     */
    private String BuildA = "汉堡";
    /**
     * 快餐 B 默认为可乐
     */
    private String BuildB = "可乐";
    /**
     * 快餐 C 默认为薯条
     */
    private String BuildC = "薯条";
    /**
     * 快餐 D 默认为甜点
     */
    private String BuildD = "甜点";
    
    public String getBuildA() {
        return BuildA;
    }
    public void setBuildA(String buildA) {
        BuildA = buildA;
    }
    public String getBuildB() {
        return BuildB;
    }
    public void setBuildB(String buildB) {
        BuildB = buildB;
    }
    public String getBuildC() {
        return BuildC;
    }
    public void setBuildC(String buildC) {
        BuildC = buildC;
    }
    public String getBuildD() {
        return BuildD;
    }
    public void setBuildD(String buildD) {
        BuildD = buildD;
    }
    @Override
    public String toString() {
        return "Product{" +
                "BuildA='" + BuildA + '\'' +
                ", BuildB='" + BuildB + '\'' +
                ", BuildC='" + BuildC + '\'' +
                ", BuildD='" + BuildD + '\'' +
                '}';
    }
}
```

- 厨房（建造者）

```java
public abstract class Kitchen {
    /**
     * 制作快餐 A
     * @param msg 快餐名称
     * @return 快餐
     */
    abstract Kitchen builderA(String msg);
    /**
     * 制作快餐 B
     * @param msg 快餐名称
     * @return 快餐
     */
    abstract Kitchen builderB(String msg);
    /**
     * 制作快餐 C
     * @param msg 快餐名称
     * @return 快餐
     */
    abstract Kitchen builderC(String msg);
    /**
     * 制作快餐 D
     * @param msg 快餐名称
     * @return 快餐
     */
    abstract Kitchen builderD(String msg);
    /**
     * 获取产品
     * @return 产品
     */
    abstract Product getProduct();
}
```

- 服务员（传递者）

```java
public class Waiter extends Kitchen {
    private Product product;
    public Waiter(){
        product = new Product();
    }
    @Override
    Kitchen builderA(String msg) {
        product.setBuildA(msg);
        return this;
    }
    @Override
    Kitchen builderB(String msg) {
        product.setBuildB(msg);
        return this;
    }
    @Override
    Kitchen builderC(String msg) {
        product.setBuildC(msg);
        return this;
    }
    @Override
    Kitchen builderD(String msg) {
        product.setBuildD(msg);
        return this;
    }
    @Override
    Product getProduct() {
        return product;
    }
}
```

- 客户

```java
// 叫服务员
Waiter waiter = new Waiter();

//可以选择套餐，省事，直接告诉服务员要套餐即可
Product product1 = waiter.getProduct();
System.out.println(product1);

//也可以自己点餐，点了哪些上哪些
//链式编程
Product product2 = waiter
    .builderA("炸鸡")
    .builderB("雪碧")
    .builderC(null)
    .builderD(null)
    .getProduct();
System.out.println(product2);
```

### 指挥者实现

> 在工地建筑时，除了建造本身，建造的顺序也非常重要，因此工地上一般都会有一个指挥者来决定建造的顺序。

![建造者UML类图](D:\Study\Learning-record\设计模式\建造者UML类图.jpg)

- 定义一栋楼（产品）

```java
/**
 * 一栋楼（产品）
 */
public class Product {
    /**
     * 地基
     */
    private String productA;
    /**
     * 主体
     */
    private String productB;
    /**
     * 粉刷
     */
    private String productC;
    /**
     * 绿化
     */
    private String productD;
    public String getProductA() {
        return productA;
    }
    public void setProductA(String productA) {
        this.productA = productA;
    }
    public String getProductB() {
        return productB;
    }
    public void setProductB(String productB) {
        this.productB = productB;
    }
    public String getProductC() {
        return productC;
    }
    public void setProductC(String productC) {
        this.productC = productC;
    }
    public String getProductD() {
        return productD;
    }
    public void setProductD(String productD) {
        this.productD = productD;
    }
    @Override
    public String toString() {
        return "Product{" +
                "productA='" + productA + '\'' +
                ", productB='" + productB + '\'' +
                ", productC='" + productC + '\'' +
                ", productD='" + productD + '\'' +
                '}';
    }
}
```

- 包工头（抽象建造者）

```java
/**
 * 包工头（抽象建造者）
 * @author yifan
 */
public abstract class Builder {
    /**
     * 打地基
     */
    abstract void buildA();
    /**
     * 建主体
     */
    abstract void buildB();
    /**
     * 去粉刷
     */
    abstract void buildC();
    /**
     * 搞绿化
     */
    abstract void buildD();
    /**
     * 建一栋楼
     * @return 一栋楼
     */
    abstract Product getProduct();
}
```

- 工人（实际建造者）

```java
/**
 * 工人（实际建造者）
 */
public class Worker extends Builder{
    private Product product;
    public Worker() {
        // 指定要建设的楼
        product = new Product();
    }
    @Override
    void buildA() {
        product.setProductA("地基");
        System.out.println("地基");
    }
    @Override
    void buildB() {
        product.setProductB("主体");
        System.out.println("主体");
    }
    @Override
    void buildC() {
        product.setProductC("粉刷");
        System.out.println("粉刷");
    }
    @Override
    void buildD() {
        product.setProductD("绿化");
        System.out.println("绿化");
    }
    @Override
    Product getProduct() {
        return product;
    }
}
```

- 施工调度员（指挥者）

```java
/**
 * 施工调度员（指挥者）
 */
public class Director {
    /**
     * 指挥包工头按照顺序建楼
     * @param builder 包工头
     * @return 楼
     */
    public Product build(Builder builder){
        builder.buildA();
        builder.buildB();
        builder.buildC();
        builder.buildD();
        return builder.getProduct();
    }
}
```

- 建楼

```java
// 施工调度员指挥包工头，包工头找到具体的工人按照施工调度员指定的顺序建造
new Director().build(new Worker());
```

## 原型模式

> 概述

**原型模式实际上就是对象的拷贝。**

原型模式使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。也就是说，原型对象作为模板，通过克隆操作，来产生更多的对象，就像细胞的复制一样。

原型模式的拷贝分为**浅拷贝**和**深拷贝**。

在 Java 中，就可以实现 Cloneable 接口提供的拷贝机制，来实现原型模式

> 使用场景

1. 资源优化场景。

2. 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。

3. 性能和安全要求的场景。

4. 通过 `new` 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。

5. 一个对象多个修改者的场景。

6. 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。

7. 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 `clone` 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，可以随手拿来使用。

![拷贝](D:\Study\Learning-record\设计模式\拷贝.jpg)

### 浅拷贝

> 对于类中**基本数据类型**，会直接复制值给拷贝对象；对于类中**引用类型**，只会复制对象的地址，而实际上指向的还是原来的那个对象。
>
> 浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。

- 需要克隆的对象需要继承`Cloneable`接口，重写`clone`方法

```java
public class Address implements Cloneable{
    private String name;
    // 省略构造函数、Getter&Setter方法
    @Override
    public Address clone() {
        try {
            return (Address) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}

public class Person implements Cloneable {
    private Address address;
    // 省略构造函数、Getter&Setter方法
    @Override
    public Person clone() {
        try {
            Person person = (Person) super.clone();
            return person;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
```

- 测试

```java
Person person1 = new Person(new Address("武汉"));
Person person1Copy = person1.clone();
// true
System.out.println(person1.getAddress() == person1Copy.getAddress());
```

### 深拷贝

> 深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

- 简单改写`clone`方法

```java
@Override
public Person clone() {
    try {
        Person person = (Person) super.clone();
        person.setAddress(person.getAddress().clone());
        return person;
    } catch (CloneNotSupportedException e) {
        throw new AssertionError();
    }
}
```

- 再次测试

```java
Person person1 = new Person(new Address("武汉"));
Person person1Copy = person1.clone();
// false
System.out.println(person1.getAddress() == person1Copy.getAddress());
```

## 适配器模式

> 概述

**结构型**模式关注如何将现有的类或对象组织在一起形成更加强大的结构。

在生活中，我们经常遇到这样的一个问题：轻薄笔记本通常只有 type-c 或者 usb-a 接口，没有网口。但日常使用中是往往需要连接网口上网的，这时想到的第一个解决方案，就是去买一个**转接头**或者**扩展坞**。它们可以将 type-c 或者 usb-a 转换为其他类型的接口供我们使用，实际上这就是一种**适配器模式**。

我们常用的充电头，为什么叫**电源适配器**呢？传统的供电是 220V 交流电，但是手机可能只需要 5V 的电压进行充电，所以虽然现在有电，但是不能直接充。也不可能让电力公司专门为我们提供一个 5V 的直流电使用，这时电源适配器就开始发挥作用了。比如苹果的祖传 5V1A 充电头，实际上就是将 220V 交流电转换为 5V 的直流电进行传输。这样就相当于在 220V 交流电和手机之间，做了一个**适配器**的角色。

适配器模式分为**类适配器**和**对象适配器。**

> 使用场景

有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。

### 类适配器（不推荐）

> 这种实现方式需要占用一个继承位。如果此时 NetToUsb 不是接口而是抽象类的话，由于 Java 不支持多继承，就无法实现了。

- 电脑

```java
public class Computer {
    /**
     * 电脑需要连接上转换器才可以上网
     *
     * @param adapter 转接器
     */
    public void connect(NetToUsb adapter) {
        // 上网的具体实现，找一个转接头
        adapter.connectNetLine();
    }
}
```

- 网线

```java
public class NetLine {
    /**
     * 上网
     */
    public void online(){
        System.out.println("连接网线上网");
    }
}
```

- 适配器接口

```java
public interface NetToUsb {
    /**
     * 处理请求，usb -> 网线
     */
    void connectNetLine();
}
```

- 适配器实现

```java
public class ClassAdapter extends NetLine implements NetToUsb {
    @Override
    public void connectNetLine() {
        // 可以上网了
        super.online();
    }
}
```

- 使用

```java
// 电脑
Computer computer = new Computer();
// 转接器已经插上网线
ClassAdapter adapter = new ClassAdapter();
// 电脑连接转接器，成功上网
computer.connect(adapter);
```

### 对象适配器

- 适配器

```java
public class ObjectAdapter implements NetToUsb {
    /**
     * 网线
     */
    private NetLine netLine;
    //手动设置适配器类别，更加灵活
    public ObjectAdapter(NetLine netLine) {
        this.netLine = netLine;
    }
    @Override
    public void connectNetLine() {
        // 可以上网了
        netLine.online();
    }
}
```

- 使用

```java
public class ObjectAdapterTest {
    @Test
    public void test() {
        // 电脑
        Computer computer = new Computer();
        // 网线
        NetLine netLine = new NetLine();
        // 转接器插上网线
        ObjectAdapter adapter = new ObjectAdapter(netLine);
        // 电脑连接转接器，成功上网
        computer.connect(adapter);
    }
}
```



