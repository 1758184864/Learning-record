## 面向对象设计原则

> 在进行软件开发时，不仅需要将基本的业务完成，还要考虑整个项目的==可维护性==和==可复用性==。
>
> 因此在编写代码时，应该尽可能的规范，不然随着项目的不断扩大，整体结构只会越来越遭。
>
> 为了避免这种情况的发生，应该尽量遵守==面向对象设计原则==。

1. **单一职责原则：**一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。==(类的划分要明确，专门的类做专门的事，不能所有的东西都写在一个类中)==
2. **开闭原则：**软件实体应当对扩展开放，对修改关闭。==（一个接口的具体实现最好的交由调用者，这样可以针对不同的业务扩展出不同的实现，灵活多变）==
3. **里式替换原则：**所有引用基类的地方必须能透明地使用其子类的对象。==（子类继承，不对父类方法进行重写，因为重写会覆盖父类方法，子类可以扩展自己的方法）==
4. **依赖倒转原则：**高层模块不应依赖于底层模块，它们都应该依赖抽象。抽象不应依赖于细节，细节应该依赖于抽象。==（spring的思想：解耦，将接口和实现类分离，便于业务变更和扩展）==
5. **接口隔离原则：**客户端不应依赖那些它不需要的接口。==（将接口细化，在继承接口时尽量不要出现此类不需要的方法）==
6. **合成复用原则：**优先使用对象组合，而不是通过继承来达到复用的目的。==（在使用它类对象方法时，尽量使用调用，而不是继承，继承的耦合性太高）==
7. **迪米特法则：**每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。==（在传参时，尽量避免过程冗余，比如能使用string的，就不要使用user.getName()）==

## 设计模式分类

![设计模式分类](D:\Study\Learning-record\设计模式\设计模式分类.png)

## 单例模式

> 什么是单例模式

1. 构造方法私有化，创建唯一实例
2. 静态属性指向实例
3. 提供静态方法，返回静态属性

> 单例模式特点

1. 单例类只能有一个实例
2. 单例类必须自己创建自己的唯一实例
3. 单例类必须给其他类提供获取实例的方法

### 饿汉式

在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的

如果在构造方法里写了性能消耗较大，耗时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿

```java
//饿汉式单例
public class Test {
    private Test() {
        
    }
    
    private final static Test TEST = new Test();
    
    public static Test getInstance() {
        return TEST;
    }
}
```

### DCL懒汉式

在调用getInstance时才创建实例对象

使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。

```java
//DCL懒汉式单例
public class Test {

    private Test() {

    }

    //volatile关键字 1.保证变量的内存可见性 2.不保证原子性 3.禁止指令重排序
    private volatile static Test test = null;

    //双重检测锁机制
    public static Test getInstance() {
        //第一次判断，实例为空，就有获取锁的资格
        if (test == null) {
            //锁住类，保证同一时间只能有一条线程进行操作
            synchronized (Test.class) {
                if (test == null) {
                   test = new Test();
                }
            }
        }
        return test;
    }
}
```

前面的写法尽管已经考虑得很完善，但还是忽略了**反射**。反射可以直接获取类，调用`newInstance`来生成对象实例

枚举类本质上也是一个类，在类的基础上进行了一些约束，**反射**无法破坏枚举类，所以我们使用枚举类来实现单例

```java
public enum Singleton {
    /**
     * 单例对象
     */
    INSTANCE
}
```

## 工厂模式

在工厂模式中，创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

如果需要创建一个对象，最简单的方式就是直接 `new`一个。而工厂模式代替了传统的直接 new 的形式，那么为什么要替代呢？**如果所有的对象都通过 new 的方式去创建，那么当程序中大量使用此对象时，突然有一天这个对象的构造方法或是类名发生了修改，那就得逐个去进行修改。**

根据**迪米特法则**，应该尽可能地少与其他类进行交互，所以可以将那些需要频繁出现的对象创建，封装到一个工厂类中。当需要对象时，直接调用工厂类中的工厂方法来生成对象，这样，就算类出现了变动，只需要修改工厂中的代码即可，而不是大面积地进行修改。同时，可能某些对象的创建并不只是一个 new 就可以搞定，可能还需要更多的步骤来准备构造方法需要的参数。

### 简单工厂模式

> 通过一个工厂，生产相同类型的不同产品

- 车的抽象类

```java
public interface Car{
    void name();
}
```

- 奔驰实现类

```java
public class BenChi extends Car{
    @Override
    public void name() {
        System.out.println("奔驰");
    }
}
```

- 宝马实现类

```java
public class BaoMa extends Car{
    @Override
    public void name() {
        System.out.println("宝马");
    }
}
```

- 车工厂

```java
public class CarFactory {
    public static Car getCar(String name){
        switch (name){
            case "奔驰": 
                Car car = new BenChi();
                //构建一些奔驰车辆的基础信息等等
                //此处省略代码1w行
                //......
                return car;
            case "宝马": 
                Car car = new BaoMa();
                //构建一些宝马车辆的基础信息等等
                //此处省略代码1w行
                //......
                return car;
            default: return null;
        }
    }
}
```

- 调用

```java
public class Test {
    public static void main(String[] args) {
        Car car1 = new CarFactory().getCar("宝马");
        Car car2 = new CarFactory().getCar("奔驰");

        car1.name();
        car2.name();
    }
}
```

### 工厂方法模式

> 同类型的不同产品都有各自的工厂进行专门的生产

==这样写有利于横向扩展，当有新的类时，我们加上它的工厂即可。但是，这样写会徒增一倍的代码量，因为每一个实现类都有自己的专属工厂。==

- 工厂接口

```java
public interface CarFactory {
    Car getCar();
}
```

- 奔驰车工厂

```java
public class BenChiFactory implements CarFactory{
    @Override
    public Car getCar() {
        Car car = new BenChi();
        //构建一些奔驰车辆的基础信息等等
        //此处省略代码1w行
        //......
        return car;
    }
}
```

- 宝马车工厂

```java
public class BaoMaFactory implements CarFactory{
    @Override
    public Car getCar() {
        Car car = new BaoMa();
        //构建一些宝马车辆的基础信息等等
        //此处省略代码1w行
        //......
        return car;
    }
}
```

- 调用

```java
public class Test {
    public static void main(String[] args) {
        Car car1 = new BenChiFactory().getCar();
        Car car2 = new BaoMaFactory().getCar();

        car1.name();
        car2.name();
    }
}
```

### 抽象工厂模式

**抽象工厂模式**是围绕一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂。

缺点：如果产品族新增了产品，那么我就不得不去为每一个产品族的工厂都去添加新产品的生产方法，违背了开闭原则。且这种模式需要使用的类远多于工厂模式，除非是类似这种产品族的业务场景，否则还是更推荐**简单工厂模式**实现。

- 创建产品接口

```java
/**
 * 手机
 */
public interface Phone {
    /**
     * 打电话
     */
    void call();
}
```

```java
/**
 * 平板
 */
public interface Pad {
    /**
     * 看视频
     */
    void video();
}
```

- 定义具体产品

```java
/**
 * 小米手机
 */
public class XiaoMiPhone implements Phone {
    @Override
    public void call() {
        System.out.println("小米手机打电话");
    }
}
```

```java
/**
 * 小米平板
 */
public class XiaoMiPad implements Pad {
    @Override
    public void video() {
        System.out.println("小米平板看视频");
    }
}
```

```java
/**
 * 华为手机
 */
public class HuaWeiPhone implements Phone {
    @Override
    public void call() {
        System.out.println("华为手机打电话");
    }
}
```

```java
/**
 * 华为平板
 */
public class HuaWeiPad implements Pad {
    @Override
    public void video() {
        System.out.println("华为平板看视频");
    }
}
```

- 创建抽象工厂

```java
/**
 * 抽象工厂
 */
public abstract class AbstractFactory {
    /**
     * 获取手机
     * @return 手机对象
     */
    public abstract Phone getPhone();
    /**
     * 获取平板
     * @return 平板对象
     */
    public abstract Pad getPad();
}
```

- 创建品牌工厂

```java
/**
 * 小米工厂
 */
public class XiaoMiFactory extends AbstractFactory{
    @Override
    public Phone getPhone() {
        return new XiaoMiPhone();
    }
    @Override
    public Pad getPad() {
        return new XiaoMiPad();
    }
}
```

```java
/**
 * 华为工厂
 */
public class HuaWeiFactory extends AbstractFactory {
    @Override
    public Phone getPhone() {
        return new HuaWeiPhone();
    }
    @Override
    public Pad getPad() {
        return new HuaWeiPad();
    }
}
```

- 调用

```java
// 小米手机
Phone xiaomiPhone = new XiaoMiFactory().getPhone();
// 华为手机
Phone huaweiPhone = new HuaWeiFactory().getPhone();
// 小米平板
Pad xiaoMiPad = new XiaoMiFactory().getPad();
// 华为平板
Pad huaweiPad = new HuaWeiFactory().getPad();
// 输出测试
xiaomiPhone.call();
huaweiPhone.call();
xiaoMiPad.video();
huaweiPad.video();
```

## 建造者模式

建造者模式使用多个简单的对象一步一步构建成一个复杂的对象。

一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。

经常使用的 `StringBuiler` 就是建造者模式的典型实现。

### 普通实现

- 产品

```java
/**
 * 快餐食品（产品）
 */
public class Product {
    /**
     * 快餐 A 默认为汉堡
     */
    private String BuildA = "汉堡";
    /**
     * 快餐 B 默认为可乐
     */
    private String BuildB = "可乐";
    /**
     * 快餐 C 默认为薯条
     */
    private String BuildC = "薯条";
    /**
     * 快餐 D 默认为甜点
     */
    private String BuildD = "甜点";
    public String getBuildA() {
        return BuildA;
    }
    public void setBuildA(String buildA) {
        BuildA = buildA;
    }
    public String getBuildB() {
        return BuildB;
    }
    public void setBuildB(String buildB) {
        BuildB = buildB;
    }
    public String getBuildC() {
        return BuildC;
    }
    public void setBuildC(String buildC) {
        BuildC = buildC;
    }
    public String getBuildD() {
        return BuildD;
    }
    public void setBuildD(String buildD) {
        BuildD = buildD;
    }
    @Override
    public String toString() {
        return "Product{" +
                "BuildA='" + BuildA + '\'' +
                ", BuildB='" + BuildB + '\'' +
                ", BuildC='" + BuildC + '\'' +
                ", BuildD='" + BuildD + '\'' +
                '}';
    }
}
```

- 厨房

```java
/**
 * 厨房（建造者）
 */
public abstract class Kitchen {
    /**
     * 制作快餐 A
     * @param msg 快餐名称
     * @return 快餐
     */
    abstract Kitchen builderA(String msg);
    /**
     * 制作快餐 B
     * @param msg 快餐名称
     * @return 快餐
     */
    abstract Kitchen builderB(String msg);
    /**
     * 制作快餐 C
     * @param msg 快餐名称
     * @return 快餐
     */
    abstract Kitchen builderC(String msg);
    /**
     * 制作快餐 D
     * @param msg 快餐名称
     * @return 快餐
     */
    abstract Kitchen builderD(String msg);
    /**
     * 获取产品
     * @return 产品
     */
    abstract Product getProduct();
}
```

